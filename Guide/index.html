<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
	<meta charset="utf-8">
	<meta name="robots" content="index,follow,noodp">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	
	<!--Standard Meta Data-->
	<meta name="description" content="YOUR SITE DESCRIPTION">
	<meta name="keywords" content="10-15 KEYWORDS BUT NO MORE">
	<meta name="author" content="GENERALLY JUST PUT YOUR SITE NAME HERE">
	
	<!--Open Graph properties (Facebook)-->
	<meta property="og:title" content="YOUR SITE TITLE">
	<meta property="og:type" content="website">
	<meta property="og:image" content="YOUR SITE ICON.png">
	<meta property="og:url" content="YOUR SITE URL">
	<meta property="og:site_name" content="YOUR SITE NAME">
	<meta property="og:description" content="YOUR SITE DESCRIPTION (same as above)">
	
	<!--Home Page Link-->
	<link rel="home" href="YOUR HOME PAGE URL"/>
	<!--Alternate Link (such as an rss feed)-->
	<link rel="alternate" type="application/rss+xml" title="RSS" href="YOUR RSS FEED URL"/>
	<!--Human Readable Sitemap-->
	<link rel="index" href="HUMAN READABLE SITE MAP URL"/>
	
	<!--YOUR CANONICAL SITE URL-->
	<link rel="canonical" href="http://YOUR SITE URL.com"/>
	
	<!--DNS Prefetch (optional)-->
	<link rel="dns-prefetch" href="//anotherhost.com"/>
	
	<!--YOUR APPLE TOUCH ICONS-->
	<link rel="apple-touch-icon" href="images/apple1.png"/>
	<link rel="apple-touch-icon" sizes="76x76" href="images/apple2.png"/>
	<link rel="apple-touch-icon" sizes="120x120" href="images/apple3.png"/>
	<link rel="apple-touch-icon" sizes="152x152" href="images/apple4.png"/>
	
	<!--YOUR PAGE TITLE-->
	<title>Latria Guide and Reference</title>
	<!--ADD YOUR GPLUS PAGE-->
	<link rel="author" href="https://plus.google.com/+YOUR GPLUS PAGE/posts"/>
	<!--ADD YOUR GPLUS PAGE-->
	<link rel="publisher" href="https://plus.google.com/+YOUR GPLUS PAGE"/>
	<!--ADD YOUR FAVICON-->
	<link rel="icon" type="image/ico" href="../images/logo.png"/>
	<link rel="stylesheet" href="guide.css"/>
	<link href="../css/font-awesome.min.css" rel="stylesheet"/>
	<!--ADD YOUR LD JSON DATA BELOW-->
	<script type="application/ld+json">
	{
	  "@context": "http://schema.org",
	  "@type": "WebSite",
	  "name": "YOUR SITE NAME",
	  "url": "http://YOUR SITE URL.com",
	  "logo": "http://YOUR SITE URL.com/images/YOUR SITE ICON",
	  "sameAs" : [
		"https://www.facebook.com/YOUR FACEBOOK PAGE",
		"https://twitter.com/YOUR TWITTER PAGE",
		"https://plus.google.com/+YOUR GPLUS PAGE/"
	  ]
	}
	</script>
	<script src="../js/jquery-1.11.3.min.js"></script>
	<script src="uphw.js"></script>
</head>
<body>

<!--Left Aligned Nav-->
<div id="left-nav">
	<a class="nav-item" onclick="$('#1').scrollView();"><strong>latria guide.</strong></a>
</div>

<!--spacer-->
<div style="height:64px"></div>

<div id="window-wrapper-div">

	<div id="side-nav">
		<a class="side-nav-item-title" href="#gettingStarted">Getting Started</a>
		<a class="side-nav-item" href="#about">A little history</a>
		<a class="side-nav-item" href="#gettingLatria">Getting Latria</a>
		<a class="side-nav-item" href="#buildingSource">Building</a>
		<a class="side-nav-item" href="#installing">Installing</a>
		<a class="side-nav-item" href="#firstScript">A Basic Script</a>
		<a class="side-nav-item" href="#types">Types</a>
		<a class="side-nav-item" href="#basicMath">Basic Math</a>
		<hr/>
		<a class="side-nav-item-title" href="#strings">Strings</a>
		<a class="side-nav-item" href="#find">find</a>
		<a class="side-nav-item" href="#substr">substring</a>
		<a class="side-nav-item" href="#replace">replace</a>
		<a class="side-nav-item" href="#match">match</a>
		<hr/>
		<a class="side-nav-item-title" href="#controlFlows">Control Flows</a>
		<a class="side-nav-item" href="#if">if</a>
		<a class="side-nav-item" href="#elseif">elseif</a>
		<a class="side-nav-item" href="#else">else</a>
		<a class="side-nav-item" href="#for">for</a>
		<a class="side-nav-item" href="#while">while</a>
		<hr/>
		<a class="side-nav-item-title" href="#random">Random</a>
		<a class="side-nav-item" href="#rand">random</a>
		<a class="side-nav-item" href="#seed">seed</a>
		<hr/>
		<a class="side-nav-item-title" href="#input">Input</a>
		<hr/>
		<a class="side-nav-item-title" href="#fileio">File IO</a>
		<a class="side-nav-item" href="#open">open</a>
		<a class="side-nav-item" href="#read">read</a>
		<a class="side-nav-item" href="#write">write</a>
		<a class="side-nav-item" href="#close">close</a>
		<a class="side-nav-item" href="#remove">remove</a>
		<hr/>
		<a class="side-nav-item-title" href="#math">Math Functions</a>
		<a class="side-nav-item" href="#sqrt">square root</a>
		<hr/>
		<a class="side-nav-item-title" href="#bitwise">Bitwise</a>
		<a class="side-nav-item" href="#not">not</a>
		<a class="side-nav-item" href="#or">or</a>
		<a class="side-nav-item" href="#xor">xor</a>
		<a class="side-nav-item" href="#and">and</a>
		<hr/>
		<a class="side-nav-item-title" href="#match_regex">Match Regex</a>
		<a class="side-nav-item" href="#capture">capture</a>
		<hr/>
		<a class="side-nav-item-title" href="#xlang">Cross Language Exec</a>
		<a class="side-nav-item" href="#interpolation">variable interpolation</a>
		<hr/>
		<a class="side-nav-item-title" href="#dynaCode">Dynamic Code</a>
		<a class="side-nav-item" href="#load">load</a>
		<a class="side-nav-item" href="#run">run</a>
		<hr/>
		<a class="side-nav-item-title" href="#sockets">Server &amp; Client</a>
		<a class="side-nav-item" href="#server">server</a>
		<a class="side-nav-item" href="#client">client</a>
		<a class="side-nav-item" href="#connect">connection</a>
		<a class="side-nav-item" href="#readDat">Read Data</a>
		<a class="side-nav-item" href="#writeDat">Write Data</a>
		<a class="side-nav-item" href="#closeConn">Close Connection</a>
		<hr/>
		<a class="side-nav-item-title" href="#gc">Garbage Collection</a>
		<a class="side-nav-item" href="#gc-about">About</a>
		<a class="side-nav-item" href="#gc-rate">Altering the collection rate</a>
		<hr/>
		<a class="side-nav-item-title" href="#additional">Additional Functions</a>
		<a class="side-nav-item" href="#sleep">sleep</a>
		<a class="side-nav-item" href="#time">time</a>
		<a class="side-nav-item" href="#platform">platform</a>
		<a class="side-nav-item" href="#purge">purge memory</a>
		<br/><br/>
	</div>


	<div id="content-window">
		
		<div class="section" id="gettingStarted">
			<h2>Getting Started.</h2>
			<p>
				Welcome to latria! I'm glad you're interested in learning about this exciting new scripting language. With latria you can expect to bridge between languages in a jiffy, stand up simple servers in a few lines and more. All in a familiar C style of programming.<br/><br/>
			    This guide will do its best to help you get up and running with latria in as little time as possible. If you follow through from the start you should have enough of an understanding in latria to build your own latria scripts. If you ever have any problems, questions or corrections concerning this guide you can contact me at <a href="mailto:ben@axolsoft.com">ben@axolsoft.com</a>.<br/><br/>
				
			</p>
		</div>
		
		<!--About Latria-->
		<div class="section" id="about">
			<h3>About latria.</h3>
			<p>
				A little about what latria is, what it's intended for, and how it came about. Firstly the project was started on a whim due to issues with embedding lua on certain systems. I am a big fan of lua, but I was wondering what if I wrote something that could be, well, even smaller. Something that was almost less of a langauge and more of a basic management system. A language that you could use to collectively manage your individual scripting languages, and tasks. Think of it like a script for a dispatch system, which just also happens to be it's own standalone system as well.<br/><br/>
				With the intention to create this 'dispatch' language I set about designing a language syntax that would match this. Just a step back to explain another thing as well. I like to say that when we program/script we aren't really making anything. Now that may seem a bit harsh, but truly we're telling the computer to utilize existing resources: memory, pixels on the screen, disk space, etc. to reorganize into our 'program'. The machine you're reading this on was already capable of doing it, it just needed to be told how. With the stress on communication it comes down to one thing, how brief can I be while still expressing proper intent? That is the general issue at hand when programming. Programs that are too concise may not be explaining how to do a task as explicitly as it should, or a bloated program may be explaining far too redundantly how to do some.<br/><br/>
				With latria the intention was to make sure that the language was simple, so intent could always be expressed briefly. If the intent is of a complex nature and requires detailed instructions, it could be written in latria, but the desire was to avoid such complex builds in latria. The incentive to the programmer is to use the embedded bridging feature of latria, a glorified piping mechanism of source. Source code from multiple languages could be written into one file, with instructions embedded on how to interpret the embedded source. The details for this mechanism will be explained in depth later on, but to sum it up developers can write 'frankenstein' scripts in latria, allowing you to dynamically interpolate the outputs of programs into other programs.<br/><br/>
				Well that's about enough said in vaguely technical terms. After first starting the project in December of 2014 the language was opensourced in December of 2015. After about a year's worth of work the language has undergone various reconstructions, tear downs, and changes of focus, but the core concept of language interpolation mentioned above was always kept at the heart. I think it's a fascinating concept to create a language that leverages other languages as one of it's core concepts, after all they may be different, but fundamentally the concepts expressed in all languages can be nearly universally translated. Similar to speaking in spanglish, or another compilation of languages in order to express an idea on the spot in a personally convenient manner, latria is intended to be expressed not by itself but in conjunction with one or more languages to complement itself.
			</p>
		</div>
		
		<!--Getting Latria-->
		<div class="section" id="gettingLatria">
			<h3>Getting Latria.</h3>
			<p>
			You have a few choices when it comes to using latria.<br/><br/>
			For either a prebuilt version or the source visit <a href="latria.uphouseworks.com">latria.uphouseworks.com</a>. Links for prebuilt binaries and the source can be found at the bottom of the site.<br/><br/>
			When possible I would recommend that you build latria from source, as the builds may not be as up to date as the current source. Currently there is build support for linux & mac using <span class="code">make mac</span> or <span class="code">make linux</span> from the terminal. For building on windows it's a bit trickier, but I'll elaborate later on.
			</p>
		</div>
		
		<!--Building From Source-->
		<div class="section" id="buildingSource">
			<h3>Building.</h3>
			<p>
			To build latria from source you'll need the code, you can grab that over from the link at <a href="latria.uphouseworks.com">latria.uphouseworks.com</a>. Once you have the source you can utilize the <span class="code">make [platform]</span> command from the terminal on mac/linux. Depending on your platform substitute the name for your given platform, for example <span class="code">make mac</span> or <span class="code">make linux</span>. Both of these commands will build a completely standalone version of latria that is capable of compiling and interpreting code. If you wish to create a smaller binary, you can build the interpreter and compiler seperately. For mac, to build the interpreter and compiler you would type the following in the console. <span class="code">make mac-interpreter</span> and <span class="code">make mac-compiler</span> (make sure to run <span class="code">make clean</span> first if you already built the standalone binary).<br/><br/>
			To see more build targets you can run <span class="code">make help</span>, which will list all valid build targets, including the debuggable targets.<br/><br/>
			To build latria for windows, it's a different story.<br/><br/>* Currently latria does not build for windows, but I will have a working build (and included build tools) in the future. If you are confortable with C and familiar with the windows build system you may try to build latria for windows still. The current method to build is via a batch script that I have yet to include, but will eventually. You must have Visual Studio's tools installed in order to build up on windows (talking about the native build system, I have not played around with alternative approaches yet). You can read more about <a href="https://msdn.microsoft.com/en-us/library/ms229859%28v=vs.110%29.aspx">finding the developer command prompt here</a>.<br/><br/>
			The line to build latria from source is as follows:
			</p>
			
			<p class="code">
			cl *.c /Felatria.exe<br/>
			</p>
			
			<p>
			This simply compiles all the source, links it and creates a binary called latria.exe. With the current mac/linux builds the entire source must be compiled first, and then linked afterwards. I haven't verified this yet, but if an error occurs from something being incorrectly referenced or not existing you can use the commands:
			</p>
			<p class="code">
			cl /c *.c<br/>
			link *.obj /out:latria.exe<br/>
			</p>
			<p>
			Make sure to look at the Makefile for latria and substitute *.c and *.obj for the proper files and objects required for what you are trying to build. Finally make sure to pass the proper compiler flags so that latria is properly configured. Again, latria does not technically build for windows at the moment, so this is on you. I will rectify this issue and have a working build soon however, so this is only if you're impatient and wish to give it a go yourself.
			</p>
		</div>
		
		<!-- Installing -->
		<div class="section" id="installing">
			<h3>Installing.</h3>
			<p>
			To set latria up on your system path for mac/linux you can use <span class="code">make install</span>, which will install the interpreter/compiler on your machine. When the windows build is finished I will add instructions for how to install on windows as well.<br/><br/>
			Once you have finished installing latria you can test whether or not latria is installed by running the command <span class="code">latria -v</span> from anywhere on your system (for mac/linux). You should see the version number of latria printed out to the console if it is properly installed.<br/><br/>
			Congratulations, you now have a working copy of latria installed locally! Now we can actually start writing some latria script.
			</p>
		</div>
		
		<!-- First Script -->
		<div class="section" id="firstScript">
			<h3>A Basic Script.</h3>
			<p>
			Keeping in line with the way things work and acknowledging the concept of languages working together, we'll write a simple script to get started.
			</p>
			<p class="code"><br/>
			print("hola mundo!")<br/>
			//a comment, prints 'hola mundo' to the console<br/><br/>
			</p>
			
			<p>
			A 'traditional' hello world program! You can write this up in a file called first.lra and run <span class="code">latria first.lra</span> to execute it. You should see a the worlds 'hola mundo!' print to the the console screen. Also notice the first.lrac file automatically generated as well, this is the compiled latria file that is actually run. For the most part you need not worry yourself with these files, however I will detail working with compiled files and bytecode for the interpreter later on.
			</p>
		</div>
		
		<!--Types-->
		<div class="section" id="types">
			<h3>Types.</h3>
			<p>
			There are 6 supported first class types in latria that you need to be aware of to get started:<br/><br/>
			<span class="naranja">
			Number<br/>String<br/>File<br/>Array<br/>Connection<br/>null</span><br/><br/> 
			<span class="naranja">Strings</span> are a basic type, bounded by either single or double quotes and containing any number of characters up to a closing single or double quote.<br/><br/>
			<span class="naranja">Numbers</span> are represented internally as a 'double' type, providing an acceptable degree of precision. A number value can be set from either a Integer or a Float value, both will be converted to double internally.<br/><br/>
			<span class="naranja">Files</span> are a type that represents an open file handle. These types are set by opening a file and used by standard IO functions.<br/><br/>
			<span class="naranja">Arrays</span> are a type that holds an arbitrary amount of key/value pairs inside of itself. Arrays can hold any type of value (although arrays in arrays are a bit off as of this moment).<br/><br/>
			<span class="naranja">Connections</span> are created when a server received a connection or a client successfully connects to a server. These are used for managing an established connection, such as writing/reading.<br/><br/>
			<span class="naranja">null</span> is a special type used to denote the absence of a value in a variable.
			<br/><br/>
			In latria these types are all associated with variables, which are dynamically typed. This means their type is determined based on the value being assigned to it. Latria automatically handles the variable appropriately based on the underlying type of the value that was assigned to it. The code below shows an example of assigning values of varying types to the same variable.
			</p>
			<p class="code">
				<br/>
				x = 2 //a Number<br/>
				print(x) //prints 2<br/>
				<br/>
				x = "bacon" //a String<br/>
				print(x) //prints 'bacon'<br/>
				<br/>
			</p>
			<p>
			Putting this in a .lra and running it should print out the following:
			</p>
			<p class="output">
				<br/>2<br/>
				bacon<br/><br/>
			</p>
			<p>
			When working with variables it is possible to change the type of a current variable depending on what you assign it to, but latria will always checks the type provided to any binary operator or function to verify it as expected. If it isn't as expected latria will print out an error to let you know.<br/><br/>
			</p>
		</div>
		
		<!-- Basic Math -->
		<div class="section" id="basicMath">
			<h3>Basic Math.</h3>
			<p>
			Arithmetic in latria is fairly straight forward, with PEMDAS order of operations prevailing over compound expressions. An example expression of arithmetic in latria is as follows.
			</p>
			<p class="code"><br/>
				x = 2 * 3 + (5 * 4 / 2) - 2<br/>
				print(x) //14<br/><br/>
			</p>
			<p>
				The standard arithmetic operators +, -, *, /, ^ and % are supported. Bitwise operators are also supported, but as system functions instead. You can find more on these functions by checking out the reference portion of this guide.
			</p>
		</div>
		
		<!--Strings-->
		<div class="section" id="strings">
			<h2>Strings.</h2>
			<p>
			Strings in latria are a useful type, allowing you create basic webservers that output data or to read/write from a file. When it comes to strings they are a special case as well, being the only other first class type that can be acted on by the + operator besides Numbers. This is referred to as string concatenation, an example of this is as follows:
			</p>
			<p class="code"><br/>
			x = "latria strings" + " glued together"<br/>
			print(x) //'latria strings glued together'<br/><br/>
			</p>
			<p>
			So, great, we can stick strings together, what else can we do? Beyond this latria provides a suite of built in system functions for performing standard operations with strings. Some of these functions include find, replace, substitution and match.<br/><br/>
			<span id="find"></span>
			<span class="naranja">Find</span> finds a string within a string, and returns the index it was found at. It takes 2 string arguments, the first the target string to search in and the second the string to find within the first string.
			</p>
			<p class="code"><br/>
			x = find("string or string", "or")<br/>
			print(x) //7<br/><br/>
			</p>
			<p>
			<span id="substr"></span>
			This by itself, is not too useful, however if we wish to use this to get a string we can use the <span class="naranja">sub string</span> function with this index we have found.
			</p>
			<p class="code"><br/>
			x = substr("string or string", 7, 9) //takes the substring between the two indexes provided in a string<br/>
			print(x) //'or'<br/><br/>
			</p>
			<p>
			Now what if we wanted to take the sub string from 7 to the end of the string? We can use the same function above with one less argument to achieve this.
			</p>
			</p>
			<p class="code"><br/>
			x = substr("string or string", 7) //takes the substring from 7 to the end of this string<br/>
			print(x) //'or string'<br/><br/>
			</p>
			<p>
			<span id="replace"></span>
			Excellent! We've taken a substring from a string. Now what if we wanted to replace that instead though. We can use the <span class="naranja">replace</span> instead.
			</p>
			<p class="code"><br/>
			x = replace("string or string", "or", "and")<br/>
			print(x) //'string and string'<br/><br/>
			</p>
			<p>
			<span id="match"></span>
			String are pretty maleable with this, but what if we want more? It turns out there's a 4th function to <span class="naranja">match</span> a string within a string by a pattern. This 'pattern' can be as simple as another raw string, like what is provided to find. However this is no ordinary function. This is a regex function! For those of you who know regex, they are a powerful component found almost universally in all languages. The underlying regex engine and the special characters it supports will be detailed later on. A simple example for now is as follows:
			</p>
			<p class="code"><br/>
			x = match("string or string", "or[^s]") //matches 'o' and 'r' followed by anything that is not 's'<br/>
			print(x)//1 (for success, 0 for failure)<br/><br/>
			</p>
			<p>
			Again, I won't go into details right here but capturing and non-capturing parentheses are supported as well, for those who care to know.
			</p>
		</div>
		
		<!-- Control Flows -->
		
		<div class="section" id="controlFlows">
			<h2>Control Flows.</h2>
			<p>
				Control flows are an essential part of any language, allowing a developer to create detailed and complex programs and scripts. If you are familiar with C style control flows most of these should be immediately familiar to you. However I will be going over each control flow in detail, so if you feel the need you may quickly pass over this section.
			</p>
			
			<h3 id="if">if.</h3>
			
			<p>
				An if statement is a staple in terms of control flows. With it you can execute code conditionally. When compounded with other if statements you can create a complex program capable of a variety of tasks (such as a language like this!). So first let's look at what a basic if statement looks like.
			</p>
			
			<p class="code"><br/>
				if( 1 == 1 ) {<br/>
					<span class="tab"></span>print("1 is equal to 1")<br/>
				}<br/><br/>
			</p>
			
			<p>
				Now to explain a bit. To start an if statement begins with the 'if' keyword, and is followed by a pair of containing parentheses wrapped around a condition. This condition is a statement that is evaluated to a boolean result. An expression can be created by comparing two values using the following:<br/> equals <span class="code">==</span>, not-equals <span class="code">!=</span>, less-than <span class="code">&lt;</span>, greater-than, <span class="code">&gt;</span>, less-than equals <span class="code">&lt;=</span> and greater-than equals <span class="code">&gt;=</span>.<br/><br/> Expressions can created by compounding these using 'And' <span class="code">&amp;&amp;</span> and 'Or' <span class="code">||</span>. Additionally these expressions can be further compounded using containing parentheses, but we won't be going into detail about that here.<br/><br/>
				  If the expression is evaluated to be true, the code contained within the following curly braces is evaluated. If false the code contained within the curly braces is skipped entirely. This conditional branching is an important concept to note.<br/><br/>
				In our statement the expression <span class="code"> 1 == 1</span> evaluates to true and our print statement is executed.
			</p>
			
			<h3 id="elseif">elseif.</h3>
			
			<p>
				An elseif statement is almost exactly like an if statement. The exception being that an elseif must always follow a preceding if or elseif statement. In this way 2 or more statements can be chained onto each other, creating a list of conditions to try. Although an elseif can follow an if, an if following an if will be treated independently. On any condition evaluating to true, it's contents are executed, and the following statements are skipped. An couple examples are as follows.
			</p>
			
			<p class="code"><br/>
				//an elseif being executed<br/>
				if( 1 == 2 ) {<br/>
					<span class="tab"></span>print("incorrect.")<br/><br/>
				} elseif( 1 == 1 ) {<br/>
					<span class="tab"></span>print("correct!")<br/><br/>
				}<br/><br/>
				//an elseif being executed before another<br/>
				if( 1 == 2 ) {<br/>
					<span class="tab"></span>print("incorrect.")<br/><br/>
				} elseif( 1 == 1 ) {<br/>
					<span class="tab"></span>print("correct!")<br/><br/>
				} elseif( 2 == 2) {<br/>
					<span class="tab"></span>print("also correct, but never run!")<br/><br/>
				}<br/><br/>
			</p>
			
			<h3 id="else">else.</h3>
			
			<p>
				An else statement is another component of an existing 'if' or 'elseif'. It is never on it's own and most always be preceded by an if or elseif statement. You can imagine an else statement something akin to a failsafe condition. If the preceding if or elseif conditions all fail, the else statement will always evaluate to true and be executed. Note that no elseifs can follow an else statement. An example of an else is as follows.
			</p>
			
			<p class="code"><br/>
				if( 1 == 2 ) {<br/>
					<span class="tab"></span>print("this can't be right...")<br/><br/>
				} elseif( 2 == 1 ) {<br/>
					<span class="tab"></span>print("and neither can this")<br/><br/>
				} else {<br/>
					<span class="tab"></span>print("i guess else will have to do!")<br/><br/>
				}<br/><br/>
			</p>
			
			<h3 id="for">for.</h3>
			
			<p>
				The for loop is a construct designed to allow a program to iterate over a section of code a certain number of times. A for loop in latria looks like the following.
			</p>
			
			<p class="code"><br/>
			//an empty for loop<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				Now what exactly did we just see? Well, for starters a for loop is always initiated with the 'for' keyword, after which an opening parenthese, followed by 3 parts and a closing parenthese, follow. It's these three elements that are the key to the functionality of a for loop. The first element, in our case <span class="code"> x = 0 </span> is what's called the initialization. The initialization declares and assigns any variables that must be used for our loop. The second element, <span class="code"> x < 10 </span>, is called the condition. The condition checks the provided condition, and exits the loop when it evaluates to false. The third and final element, <span class="code"> x = x + 1 </span>, is called the afterthought. The afterthought is a line of code that is executed once at the end of every iteration.<br/><br/>
				When you put these three together one can see we are simply assigning x to 0, checking that x is less than 10, and incrementing x by 1 at the end of every iteration. The last bit would be to address those curly braces, which indicate the start and stop of the code we will be looping over. Anything written in here will be executed until the loop evaluates to false. Using the above example we can see this by printing out the value of x every time we loop.
			</p>
			
			<p class="code"><br/>
				//a printing for loop<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/><br/>
				<span class="tab"></span>print(x)<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				This should print out the values 0-9, each on separate lines. So great, we can loop over whatever we like. What if we want to skip an iteration though? This is possible by using the <span class="naranja">continue</span> keyword. Similar to it's usage in C based languages, continue simply skips to the end of the current loop and executes the afterthought (mentioned earlier). Let's say we wanted to skip printing the number 5? We can do that by putting a continue in an if statement.
			</p>
			
			<p class="code">
				//a printing for loop that skips 5<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/><br/>
				<span class="tab"></span>if( x == 5 ) {<br/>
				<span class="tab"></span><span class="tab"></span>//skip this iteration<br/>
				<span class="tab"></span><span class="tab"></span>continue<br/>
				<span class="tab"></span>}<br/>
				<span class="tab"></span>print(x)<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				This prints out the values 0-9 while skipping 5. That's great, but what if we wanted to simple exit the loop altogether at 5? We could alter the condition of the for loop, but we can also use the <span class="naranja">break</span> keyword to 'break' out of the loop. An example of this is as follows
			</p>
			
			<p class="code">
				//a printing for loop that breaks out at 5<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/><br/>
				<span class="tab"></span>if( x == 5 ) {<br/>
				<span class="tab"></span><span class="tab"></span>//break out<br/>
				<span class="tab"></span><span class="tab"></span>break<br/>
				<span class="tab"></span>}<br/>
				<span class="tab"></span>print(x)<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				Now this prints out the values 0-4, exiting the loop when the value is 5.
			</p>
			
			<h3 id="while">while.</h3>
			
			<p>
				The while loop is a construct similar to a for loop, allowing a program to loop over a given section of code. A while loop is like a for loop that has no initialization sequence and no afterthought sequence (as mentioned in for), only retaining the condition. This condition is evaluated before each run, and if evaluated to true, executes another loop. When this condition evaluates to false, the loop is exited. An example of a while loop is below.
			</p>
			
			<p class="code"><br/>
				x = 0<br/><br/>
				// a while loop counting up to 10<br/>
				while( x &lt;= 10 ) {<br/>
					<span class="tab"></span>//print x<br/>
					<span class="tab"></span>print(x)<br/>
					<br/>
					<span class="tab"></span>//increment x by 1<br/>
					<span class="tab"></span>x = x + 1<br/>
				}<br/><br/>
			</p>
			
			<p>
				 Similarly to a for loop, you can also use <span class="code">continue</span> and <span class="code">break</span> to skip an iteration or to exit the loop entirely.
			</p>
			
			<p class="code"><br/>
				x = 0<br/><br/>
				// a while loop counting up to 10, but skipping 5<br/>
				while( x &lt;= 10 ) {<br/>
					<span class="tab"></span>if( x == 5 ) {<br/>
					<span class="tab"></span><span class="tab"></span>//increment one up (otherwise we will loop forever) and skip this iteration<br/>
					<span class="tab"></span><span class="tab"></span>x = x +1<br/>
					<span class="tab"></span><span class="tab"></span>continue<br/>
					<span class="tab"></span>}<br/>
					<span class="tab"></span>//print x<br/>
					<span class="tab"></span>print(x)<br/>
					<br/>
					<span class="tab"></span>//increment x by 1<br/>
					<span class="tab"></span>x = x + 1<br/>
				}<br/><br/><br/>
				x = 0<br/><br/>
				// a while loop counting up to 5<br/>
				while( x &lt;= 10 ) {<br/>
					<span class="tab"></span>if( x == 5 ) {<br/>
					<span class="tab"></span><span class="tab"></span>//break out<br/>
					<span class="tab"></span><span class="tab"></span>break<br/>
					<span class="tab"></span>}<br/>
					<span class="tab"></span>//print x<br/>
					<span class="tab"></span>print(x)<br/>
					<br/>
					<span class="tab"></span>//increment x by 1<br/>
					<span class="tab"></span>x = x + 1<br/>
				}<br/><br/>
			</p>
			
		</div>
		
		<!-- Random -->
		<div class="section" id="random">
			<h2>Random.</h2>
			<p id="rand">
			Latria encapsulates the standard 'rand' function in C. Making it available via the function <span class="naranja">random</span>. It's takes one Number argument and returns a Number.
			</p>
			<p class="code"><br/>
			x = random(1024)<br/>
			print(x) //a random number between 0 and 1023<br/><br/>
			</p>
			<p id="seed">
			The rand function is a pseudorandom number generator. Meaning it's output is predictable from a given seed. In order to prevent random from returning the same series of values on startup it is recommended that you alter it using the <span class="naranja">seed</span> function, which takes one Number arg and does not return a value.
			</p>
			<p class="code"><br/>
			//x is equal to a previously obtained arbitrary Number<br/>
			seed(x) //seeds the random number generator with this Number<br/><br/>
			y = random(1024)<br/>
			print(y) //a 'hopefully' unexpected random number between 0 and 1023<br/><br/>
			</p>
			<p>
			With these two functions you can create a reliable prng (pseudo-random number generator) to create psuedo-arbitrary values from.
			</p>
		</div>
		
		<div class="section" id="input">
			<h2>Input.</h2>
			<p>
			Reading user input is a simple but important feature of any language. In latria it is achieved via the <span class="naranja">input</span> function. When called it halts until the user finishes typing their input and hits enter. Upon completion it returns a String value.
			</p>
			<p class="code"><br/>
			x = input() //waits for user to enter input<br/>
			print("You entered: " + x)<br/><br/>
			</p>
			<p>
			User input can be used to allow selections, seeding of random values and even to chat in a simple server/client setup.
			</p>
		</div>
		
		<!-- File IO -->
		<div class="section" id="fileio">
			<h2>File IO.</h2>
			<p>
			In latria the ability to read files is an important aspect. Reading and writing files is supported, but binary is not (potentially in the future when a 'char' type is added). In keeping with the overall design, reading from files is incredibly simply, reading only 1 line at a time. Writing is straightforward as well, writing only one line at a time. All the file modes that are supported in C ( w, r, r+, a+, etc.) are supported in latria.<br/><br/>
			</p>
			
			<h3 id="open">Opening a file.</h3>
			<p>
				To open a file you can use the <span class="naranja">open</span> function, which takes two string arguments. The first is the name of the file, and the second is the mode to open it in ( r, w, a+, etc.). On success this function will return a valid pointer to a file that can used in latria.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "r")<br/><br/>
			</p><br/>
			
			<h3 id="read">Reading from a file.</h3>
			<p>
			To read from a file you use the <span class="naranja">read</span> function, which takes a single File argument. It will return lines or null on the reaching the end of the file.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "r")<br/>
			line = read(x)<br/>
			print(line) //a line we read from 'file.txt'<br/><br/>
			</p>
			
			<h3 id="write">Writing to a file.</h3>
			<p>
			To write to a file you use the <span class="naranja">write</span> function, which takes a File argument and a String argument. The string value is written out as a line in the file.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "w")<br/>
			write(x,"a line!") //writes a line into this file<br/><br/>
			</p>
			
			<h3 id="close">Closing a file.</h3>
			<p>
			Once you are done reading or writing to a file use <span class="naranja">close</span> to close the file. It takes a single argument, being the File to close.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "r")<br/>
			line = read(x)<br/>
			print(line)<br/><br/>
			close(x) //closes this file<br/><br/>
			</p>
			
			<h3 id="remove">Removing a File.</h3>
			<p>
			If you wish to remove a file completely you can call <span class="naranja">remove</span> to delete it. Remove takes the name of the file as a String argument.
			</p>
			<p class="code"><br/>
			remove("file.txt") //deletes this file<br/><br/>
			</p>
		</div>
		
		<!-- Math -->
		<div class="section" id="math">
			<h2 id="sqrt">Math.</h2>
			<p>
				Latria provides only one math function at this time, the <span class="naranja">square root</span> function. It takes one Number argument and returns the square root of the given value.
			</p>
			<p class="code"><br/>
			x = sqrt(64)<br/>
			print(x) //8<br/><br/>
			</p>
		</div>
		
		<!-- Bitwise -->
		<div class="section" id="bitwise">
			<h2>Bitwise.</h2>
			<p>
				Latria provides bitwise operations in the form of function calls. The provided bitwise functions are listed below with examples:
			</p>
			
			<h3 id="not">not.</h3>
			<p>
				The bitwise 'not' operator is expressed using the function <span class="naranja">not</span>. It is often referred to as the complement operator, performing a logical negation on the bits of the passed in value. 0's become 1's, and 1's become 0's, 'flipping' the value.
			</p>
			<p class="code"><br/>
				x = not(100)<br/>
				print(x) //-101<br/><br/>
			</p>
			
			<h3 id="or">or.</h3>
			<p>
				The bitwise inclusive or (or) operator is expressed using the function <span class="naranja">or</span>. It takes two Number arguments. The resulting output bits are 0 for each position where bits in both arguments are 0, otherwise they are 1.
			</p>
			<p class="code"><br/>
				x = or(101,500)<br/>
				print(x) //501<br/><br/>
			</p>
			
			<h3 id="xor">xor.</h3>
			<p>
				The bitwise exclusive or (xor) operator is expressed using the function <span class="naranja">xor</span>. It takes two Number arguments. The resulting output bits are 1 for each position where only the first bit is 1 or only the second bit is 1, otherwise they are 0.
			</p>
			<p class="code"><br/>
				x = xor(101,500)<br/>
				print(x) //401<br/><br/>
			</p>
			
			<h3 id="and">and.</h3>
			<p>
				The bitwise and (and) operator is expressed using the function <span class="naranja">and</span>. It takes two Number arguments. The output bits are the result of the first and second bit being multiplied.
			</p>
			<p class="code"><br/>
				x = and(101,500)<br/>
				print(x) //100<br/><br/>
			</p>
			
		</div>	
		
		<!-- Match Regex -->
		<div class="section" id="match_regex">
			<h2>Match Regex.</h2>
			<p>
				A basic regular expressions engine is provided in latria for matching purposes. It supports most of the basic regular expression syntax with a few exceptions (most notably look-ahead and look-behind). This engine can be used to match against strings and to even return the portion matched within a string.
			</p>
			<p>
				Regular expressions are utilized by calling the <span class="naranja">match</span> function. Which takes two parameters, a target string, and a string representation of a regular expression to use on the target string.
				A simple example is as follows.
			</p>
			<p class="code"><br/>
				x = match("a basic string", "basic") //will return 1 for a match and 0 for a non-match<br/>
				print(x) //prints 1, indicating a match (0 is a non-match)<br/><br/>
			</p>
			<p>
				A simple match, so let's try something a little more substantial.<br/>Let's try and match anything starting with 'b'.
			</p>
			<p class="code"><br/>
				x = match("a less basic string", "b.*") //matching b followed by anything<br/>
				print(x) //1<br/><br/>
			</p>
			<p>
				So far so good, but we can do better with capturing parentheses.<br/>
			</p>
			<h3 id="capture">capture.</h3>
			<p>
				Capturing parentheses are supported in latria, allowing you to match and return specific sub-strings.<br/>
			</p>
			<p class="code"><br/>
				x = match("a simple string", "(simple)") //searches for 'string' and returns 1 if found in the target string<br/>
				x = capture(0) //returns the first completed capture 'simple'<br/><br/>
				// a more complex match<br/><br/>
				x = match("another string", "([a-z]+)\s")<br/>
				x = capture(0) //returns the first completed capture, 'another'<br/><br/>
			</p>
		</div>
		
		
		<!-- XLang -->
		<div class="section" id="xlang">
			<h2>Cross Language Execution.</h2>
			<p>
				It's an important point to stress that latria's strength is in how it works with other languages. Executing code in a shell environment can open up a wealth of potential resources to be used as you see fit.
				It is these additional resources that can be utilized to 'extend' latria's functionality on a system by system basis. This comes as a doubly beneficial aspect, providing a way to retrofit latria on the go and allowing you to utilize other scripts and programs that you have on your local machine.
				<br/><br/>
				With all of that said, this part of latria is just a glorified 'piping' or 'bridging' mechanism. Even so it stands out in a unique syntactical style all it's own, as well as allowing multiple lines in your script to be executed in the same shell. This multi-line aspect becomes incredibly useful for literally inlining other languages (when needed), or simply to include a few configuration steps in addition to calling another program or script. Anything that would be valid in a shell environment on your local machine would be just as valid here.<br/><br/>
				So, how does this work? Latria provides a special syntax to execute code in a shell on your local system. 
				It is defined by an opening and closing block sequence, both of which must not be followed or preceded by anything (with the exception of assigning the block's result to a variable, that will come up in a moment)<br/><br/>
				Here's a simple example below.
			</p>
			
			<p class="code"><br/>
				//opening sequence, after this everything is executed verbatim in a shell environment (including comments) up to a valid closing sequence<br/>
				##<br/>
				echo done on the shell<br/>
				#><br/>
				//closing sequence, after this everything is interpreted normally as latria code<br/><br/>
			</p>
			
			
			<p>
				Now upon running this you may have realized something, nothing happens. Well, technically <span style="font-style:italic">something</span> happens. 
				The issue is that we're just not capturing what our <span style="font-style:italic">shell</span> did. It certainly did echo the provided statement, but only to itself and not out to latria.<br/><br/>
				We can rectify this by assigning the result of our shell to a latria variable. Modifying the example above, assignment looks a little something like this.
			</p>
			
			<p class="code"><br/>
				//assigns the result of what is executed on the shell below into the variable 'var'<br/><br/>
				var##<br/>
				echo done on the shell<br/>
				#><br/><br/>
				print(var) //prints 'done on the shell\n' (note the extra linebreak that comes from the shell output)<br/><br/>
			</p>
			
			<p>
				With this you can execute whatever you'd like in latria and be able to include results from system shell executions. Additionally these shell executions can be spread out across as many lines as you like for legibility.<br/><br/>
				There is an important rule you must regard however. An opening sequence must <span style="font-style:italic">never</span> be followed by code, and a closing sequence must <span style="font-style:italic">never</span> be preceded by code.<br/><br/>
				A few examples of this are as follows.
			</p>
			
			<p class="code"><br/>
				//can't do this<br/>
				var##echo this<br/>
				#><br/><br/>
				
				//or this<br/>
				var##<br/>
				echo this#><br/><br/>
				
				//or this<br/>
				var##echo this#><br/><br/>
			</p>
			
			<h3 id="interpolation">interpolation.</h3>
			
			<p>
				We can get output from our shell executions, but what if we want to alter what we send programmatically?
				To solve this variable interpolation is supported in shell executions. The syntax is a bit bulky, but it's designed to be very obvious regardless of what language you're interpolating a latria variable into, minimizing any confusion on where and when you're interpolating a value.
			</p>
			<p class="code"><br/>
				<br/>
				//assign x to 'bacon'<br/>
				x = 'bacon'<br/>
				<br/>
				//interpolate x into our shell execution<br/>
				var##<br/>
				echo IN{x}<br/>
				#><br/>
				<br/>
				print(var) //prints 'bacon\n'<br/><br/>
			</p>
			
			<p>
				It is important to note that currently only variables are supported in this form of interpolation. In the future function calls will be as well.
			</p>
		</div>
		
		<!-- Dynamic Code -->
		<div class="section" id="dynaCode">
			<h2>Dynamic Code.</h2>
			<p>
				Since Latria is a scripting language it can be interpreted dynamically, which gives us the opportunity to execute latria code from inside latria or to execute additional latria scripts. This gives incredible flexibility to latria, allowing one to modularize their code and simply load up that section when needed. This means changes are reflected quickly, and there is no need to recompile latria code repeatedly, this is handled for you on an as needed basis.
			</p>
			
			<h3 id="load">load.</h3>
			<p>
				Load allows you to run a latria script in the context of your current script. The child script you fire up will have access to all of the current variables and functions that are available to your calling script's scope.<br/><br/>This function is provided as <span class="naranja">load</span> and only takes 1 argument, the relative path to the script to load.
			</p>
			
			<p class="code"><br/>
				//loads a latria script<br/>
				load("myscript.lra")<br/><br/>
			</p>
			
			<h3 id="run">run.</h3>
			
			<p>
				Run allows you to attempt to dynamically interpret and run latria code from a string. This is provided as the function <span class="naranja">run</span> and only takes 1 argument, the string to interpret and run as latria code.
			</p>
			
			<p class="code"><br/>
				//assign a string<br/>
				x = "print('valid latria')"<br/><br/>
				//attempt to interpret and run this string as latria code<br/>
				run(x) //prints 'valid latria'<br/><br/>
			</p>
		</div>
		
		
		<div class="section" id="sockets">
			<h2>Server &amp; Client.</h2>
			<p>
				In today's world nearly everything is interconnected. In response latria incorporates server and client functionality as a basic need in this day and age. With the built in support for server and client functionality setting up either can be done in as few as a couple lines of code. When a connection is established both parties can either read, write or terminate the connection.
			</p>
			
			<h3 id="server">server.</h3>
			<p>
				Setting up a server in latria is a very straightforward process. To set up a server one need only call the <span class="naranja">startServer</span> function. This function takes only one number argument, the port number to bind to. An example of starting a server is as follows.
			</p>
			
			<p class="code"><br/>
				/*<br/>
				listens for an incoming connection on port 5000<br/>
				NOTE this blocks until the script is terminated or an incoming connection is made<br/>
				*/<br/><br/>
				
				x = startServer(5000)<br/>
				<br/>
				//'x' now references an established connection (successful or failed)<br/><br/>
			</p>
			
			<p>
				Be aware that calling this function will block until a connection is made.
			</p>
			
			<h3 id="client">client.</h3>
			
			<p>
				A client side application in latria is just about as simple as it is to create a server-side one. The <span class="naranja">connect</span> function is called with two arguments, a string of the ip address (IPv4) to connect to and a number for the port to try. Similarly to the 'startServer' function, the 'connect' function returns what's referred to as a 'connection' object. That will be explained in just a moment, but first let's see how connecting to a server looks written out.
			</p>
			
			<p class="code"><br/>
				//attempts to connect to a server at the address on the port given<br/><br/>
				x = connect("127.0.0.1", 5000)<br/>
				//'x' now references an established connection (successful or failed)<br/><br/>
			</p>
			
			
			<h3 id="connection">connection.</h3>
			
			<p>
				As mentioned before a connection is managed via a 'connection' object. A connection object is returned from 'startServer' or 'connect' when a connection is established. When a connection attempted by the 'connect' function fails however, it returns a -1 value, which should be checked before continuing.<br/><br/>
				A connection is a first class citizen, capable of being passed and returned like any other value. Once a connection has been obtained it can be manipulated by 3 distinct functions: readData, writeData and closeConnection.
			</p>
			
			<h3 id="readDat">Read Data.</h3>
			
			<p>
				Reading data from an established connection is done through the <span class="naranja">readData</span> function, which takes 1 established connection as an argument and returns a string of the data read. It is important to note that this is a blocking call, and will remain so until data is available to be read from the connection. With this in mind take care not to immediately call 'readData' when it is possible there may not be data to read. If you do this there is a risk of a hangup with both sides simply listening forever! With that noted, here's an example of reading data from an established connection.
			</p>
			
			<p class="code"><br/>
				//connect to a server on port 5000<br/>
				x = connect("127.0.0.1", 5000)<br/>
				<br/>
				//read data from our connection, returns a string<br/>
				read = readData(x)<br/>
				<br/>
				//print what we read<br/>
				print(read)<br/><br/>
			</p>
			
			<h3 id="writeDat">Write Data.</h3>
			
			<p>
				Writing data to an established connection is done through the <span class="naranja">writeData</span> function, which takes an established connection and a string value to write as arguments. It returns a number value of the number of bytes written to the output stream. If you write a string such as "meep meep" and 'writeData' returns a value of 0 you can be relatively sure that the other side has disconnected or is otherwise no longer available. Here's an example of writing over an established connection and checking if we sent successfully using an if-else statement.
			</p>
			
			<p class="code"><br/>
				//connect to a server on port 5000<br/>
				x = connect("127.0.0.1", 5000)<br/>
				<br/>
				result = writeData(x,"meep meep")<br/>
				<br/>
				//check the value to make sure we wrote out successfully<br/>
				if(result == 0) {<br/>
					<span class="tab"></span>print("Error! Was unable to write to the stream.")<br/>
				} else {<br/>
					<span class="tab"></span>print("Success!")<br/>
				}<br/><br/>
			</p>
			
			<h3 id="closeConn">Close Connection.</h3>
			
			<p>
				Closing an established connection is something you should make a habit of when you're all done. It's a manner of good housekeeping, to speak. Closing a connection frees up not only the associated variable but also any underlying resources the system has involved in this connection as well. To do this you call the <span class="naranja">closeConnection</span> function, passing a connection argument. Below is an example of the whole connection life cycle from the client's perspective with the connection being closed at the end.
			</p>
			
			<p class="code"><br/>
				//Shows the whole cycle of connecting to a server, writingData, readingData, and closing the connection<br/><br/>
				//connect to a server on port 5000<br/>
				x = connect("127.0.0.1", 5000)<br/>
				<br/>
				result = writeData(x,"meep meep")<br/>
				<br/>
				//check the value to make sure we wrote out successfully<br/>
				if(result == 0) {<br/>
					<span class="tab"></span>print("Error! Was unable to write to the stream.")<br/>
				} else {<br/>
					<span class="tab"></span>print("Wrote successfully!")<br/>
				}<br/><br/>
				//reads data from the connection source<br/>
				read = readData(x)<br/>
				<br/>
				//prints what we read<br/>
				print(read)<br/><br/>
				//Closes our connection<br/>
				closeConnection(x)<br/><br/>
			</p>
		</div>
		
		<!-- Garbage Collection -->
		<div class="section" id="gc">
			<h2>Garbage Collection.</h2>
			
			<p>
				Latria is a garbage collected language. The user need not worry about managing memory manually. On the other hand it is important that this 'garbage collection' is given attention, as it can lead to undesirable circumstances should the user not be careful. The summary below is a bit technical but I recommend you going over it.
			</p>
			
			<h3 id="gc-about">About.</h3>
			
			<p>
				To start I'll relate the inner workings in an abstract way. Normally a GC could be described by such things as conservative, precise, mark-and-sweep, incremental, etc. The GC in Latria does not fit into any one of these categories completely, and in a technical sense it isn't even really a GC at all. The way this collection system works is something that can be generally described as follows.<br/><br/>
				Imagine a recycling plant that takes whatever you give them. When possible they recycle and return whatever is given to them. It's easy to imagine that over time they would inevitably end up with a large quantity of unusable junk which they would have to eventually dispose of. They would like to dispose of this junk as infrequently as possible, as it takes a large amount of time to do, so they wait until they can't handle anything else. Once they're reached capacity, they dispose of everything they're holding, creating room for more junk/recyclables.<br/><br/>
				Ultimately Latria's 'garbage collector' is more accurately a dynamically formed memory pool. This pool is very similar to the aforementioned recycling plant. Every time you set a variable to <span class="code">null</span> or a variable falls out of scope, it is trashed. These trashed variables end up in our pool. In addition to the variables you see, <span style="font-style:italic">all</span> latria's allocation logic is managed by way of this pool. When any allocations are made (internally or by the user) latria makes a request to the pool for a block. The pool then rummages around through it's 'junk' and looks for a chunk of memory that is of the appropriate size. Upon finding a block that is at least large enough, the pool returns that block (a pointer to it to be exact). If the pool does not find a valid block it defers to requesting a block via a managed call to malloc.<br/><br/>
				Great, so now we have a chunk of memory to do with as we please. What happens when we no longer want this memory? We return it to the system! Now in C this is usually achieved via the 'free' function, which does as it says. However, in C, there is not only an overhead to allocation, but also to freeing. In addition, memory is memory. It's universal despite what it may be containing. With this in mind, Latria attempts to recycle memory rather than free it. Not only can we avoid a future malloc but we can potentially keep our memory footprint indefinitely small<br/><br/> 
				With this scheme a few issues rise though. One being we can only hold so much memory to recycle before we need to start giving back, and two we don't have a way of telling whether two variables reference the same underlying object. Within latria itself, this is not a problem. The calls to allocate and free memory are synonymous with malloc and free in how they are utilized. The problem of multiple references to a single object becomes an issue when the user assigns a File value to an additional variable. When done both variables will reference the same File, and if one is closed the other will become an invalid pointer. It is at this point that this designs becomes, faulty. When working with such objects it is best to avoid multiple references when possible, and when not possible they should be treated with caution.<br/><br/>
				To more technically describe this memory is freed to and allocated from the pool's contents whenever possible. When not possible the pool is bypassed and memory is asked for using a managed call to malloc. When this memory is freed later on it is added to the pool as an additional resource. When latria is shutdown or a scope is exited any allocated memory from the enclosing scope or the latria vm is sent to this pool. When the pool exceeds a certain size latria momentarily defers itself to managing the flushing of the pool. Generally this goes unnoticed, but should the user allow an enormous max program size (more on that later), a flush could very well freeze the program for a few seconds or more. However the default maximum pool size should be more than sufficient to allow for smooth operation.<br/><br/>
				
			</p>
			
			<h3 id="gc-rate">Altering the collection rate.</h3>
			
			<p>
				So, having established that this GC is more along the lines of a recycler, how do we indicate how much we're willing to hold? Their is a function <span class="code">__setGCRate</span> which takes a single number value, the value by which to multiply the pool's size. The baseline pool size is 1024 bytes. Passing 2.0 would double the pool size, while 0.5 would halve it. By running your program with a pool size of 0 you can run latria at just over 500kb. Using the aforementioned function you could modify the 'collection' rate as follows.
			</p>
			
			<p class="code"><br/>
				//sets the pool size to 0, freeing all memory immediately after being added to the pool<br/>
				__setGCRate(0.0)<br/><br/>
				//note this has a performance hit, but if memory is an issue latria can run at just over 500kb using this<br/><br/>
			</p>
			
		</div>
		
		<!-- Additional Functions -->
		<div class="section" id="additional">
			<h2>Additional Functions.</h2>
			
			<p>
				The following are additional latria functions that didn't quite make it into a category of their own. While they are important, they can be summed up here.
			</p>
			
			<h3 id="sleep">sleep.</h3>
			
			<p>
				The <span class='naranja'>sleep</span> function is called with a single number argument, indicating the number of seconds to sleep.
			</p>
			
			<p class="code"><br/>
				//sleeps for 2 seconds<br/>
				sleep(2)<br/><br/>
			</p>
			
			<h3 id="time">time.</h3>
			
			<p>
				Returns the current time as a number since 00:00 hours, Jan 1, 1970 UTC. You can get this time by calling <span class="naranja">time</span> with no arguments.
			</p>
			
			<p class="code"><br/>
				//gets the current time since 00:00 hours, Jan 1, 1970 UTC<br/>
				x = time()<br/>
				<br/>
			</p>
			
			<h3 id="platform">platform.</h3>
			
			<p>
				Returns the name of the platform as a string that this instance of latria was compiled for. Called via the function <span class="naranja">platformName</span> with no arguments. The possible values it can return are mac, linux, windows, or undefined.
			</p>
			
			<p class="code"><br/>
				//returns the platform name<br/>
				x = platformName()<br/><br/>
				//prints the platform name<br/>
				print(x)<br/><br/>
			</p>
			
			<h3 id="purge">purge memory.</h3>
			
			<p>
				Purges all allocated variables, functions, etc. You can call this via the function <span class="naranja">__purge</span> with no arguments and no return value.
			</p>
			
			<p class="code"><br/>
				//set x to something<br/>
				x = "something"<br/>
				//prints 'something'<br/>
				print(x)<br/>
				<br/>
				__purge()<br/>
				<br/>
				//prints 'null'<br/>
				print(x)<br/><br/>
			</p>
			
		</div>
		
		<!--TEMPLATE-->
		<!--
		<div class="section" id="bitwise">
			<h2>Bitwise.</h2>
			<p>
				Latria provides bitwise operations in the form of function calls. The provided bitwise functions are listed below with examples:
			</p>
			
			<h3 id="not">not.</h3>
			<p>
				The bitwise 'not' operator is expressed using the function <span class="naranja">not</span>. It is often referred to as the complement operator, performing a logical negation on the bits of the passed in value. 0's become 1's, and 1's become 0's, 'flipping' the value.
			</p>
			<p class="code"><br/>
				x = not(100)<br/>
				print(x) //-101<br/><br/>
			</p>
		</div>
		-->
			
	</div>

</div>
		
		
<!--Footer-->
<div id="footer">

	<div class='footer-section'>
		<p class='footer-section-title'>Contact</p>
		<a class='footer-section-item' href="mailto:friedman.benjamin@gmail.com"><span class="fa fa-envelope fa-2x"></span></a><br/>
		<a class='footer-section-item' href="https://github.com/montymxb"><span class="fa fa-github fa-2x"></span></a>
	</div>

	<div class='footer-section'>
		<p class='footer-section-title'>Home</p>
		<a class='footer-section-item' href="http://uphouseworks.com">uphouseworks.com</a>
	</div>
	
	<div class='footer-section'>
		<p class='footer-section-title'>Work</p>
		<a class='footer-section-item' href="http://www.axolsoft.com">axolsoft</a>
	</div>

	<div class='footer-section'>
		<p style='font-size: 16px; color: #707070'>Guide Revision 1 for Latria v0.1.0</p>
		<p style='font-size: 16px; color: #707070'>Copyright © 2015 Benjamin Wilson Friedman, All rights reserved.</p>
	</div>
</div>

</body>
</html>