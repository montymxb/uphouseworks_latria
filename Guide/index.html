<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#" lang="en">
<head>
	<meta charset="utf-8">
	<meta name="robots" content="index,follow,noodp">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="A guide to learning the Latria scripting language from beginning to end. Augment your workflows and expedite the ability to bridge your work together by learning to use Latria to supplement your scripting repertoire.">
	<meta name="keywords" content="script,language,embeddable,lightweight,guide,learning,scripting,learn,program,multi,communication">
	<meta name="author" content="Benjamin Wilson Friedman">
	<meta property="og:title" content="Latria | Language Guide">
	<meta property="og:type" content="website">
	<meta property="og:image" content="http://latria.uphouseworks.com/images/og_image.png">
	<meta property="og:url" content="http://latria.uphouseworks.com/Guide">
	<meta property="og:site_name" content="Latria | Language Guide">
	<meta property="og:description" content="A guide to learning the Latria scripting language from beginning to end. Augment your workflows and expedite the ability to bridge your work together by learning to use Latria to supplement your scripting repertoire.">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="@mxbdev">
	<meta name="twitter:creator" content="@mxbdev">
	<meta name="twitter:title" content="Latria | Language Guide">
	<meta name="twitter:description" content="A guide to learning the Latria scripting language from beginning to end. Augment your workflows and expedite the ability to bridge your work together by learning to use Latria to supplement your scripting repertoire.">
	<meta name="twitter:image" content="http://latria.uphouseworks.com/images/twimage-large.png">
	<meta name="theme-color" content="#ffffff">
	<meta name="HandheldFriendly" content="true">
	<meta name="msapplication-TileColor" content="#ffffff">
	<link rel="home" href="http://latria.uphouseworks.com"/>
	<link rel="canonical" href="http://latria.uphouseworks.com/Guide"/>
	<title>Latria | Scripting Language Guide</title>
	<link href='http://fonts.googleapis.com/css?family=Josefin+Sans:600,300,100' rel='stylesheet' type='text/css'/>
	<link rel="icon" type="image/ico" href="../images/logo.png"/>
	<link rel="stylesheet" href="guide.css"/>
	<link href="../css/font-awesome.min.css" rel="stylesheet"/>
	<script type="application/ld+json">
	{
	  "@context": "http://schema.org",
	  "@type": "WebSite",
	  "name": "Latria | Language Guide",
	  "url": "http://latria.uphouseworks.com/Guide",
	  "logo": "http://latria.uphouseworks.com/images/logo.png",
	}
	</script>
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-47712445-4', 'auto');
	  ga('send', 'pageview');
	</script>
	<script src="../js/SmoothScroll.js"></script>
	<!--<script src="../js/jquery-1.11.3.min.js"></script>-->
	<!--<script src="uphw.js"></script>-->
</head>
<body>

<!--Left Aligned Nav-->
<div id="right-nav">
	<a class="nav-item" href="../" style="text-decoration:none">latria.</a>
	<a class="nav-item" onclick="SmoothScroll.scrollToId('gettingStarted')"><strong>guide</strong></a>
</div>

<!--spacer-->
<div style="height:64px"></div>

<div id="window-wrapper-div">

	<div id="side-nav">
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('gettingStarted')">Getting Started</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('about')">A little history</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('gettingLatria')">Getting Latria</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('buildingSource')">Building</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('installing')">Installing</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('firstScript')">A Basic Script</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('syntax')">Basic Syntax</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('types')">Types</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('basicMath')">Basic Math</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('strings')">Strings</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('find')">find</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('substr')">substring</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('replace')">replace</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('match')">match</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('arrays')">Arrays</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('initializing')">initializing an array</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('accessing')">accessing elements</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('controlFlows')">Control Flows</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('if')">if</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('elseif')">elseif</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('else')">else</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('for')">for</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('while')">while</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('functions')">Functions</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('calling')">calling</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('declaring')">declaring</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('returning')">returning</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('random')">Random</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('rand')">random</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('seed')">seed</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('input')">Input</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('fileio')">File IO</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('open')">open</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('read')">read</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('write')">write</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('close')">close</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('remove')">remove</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('math')">Math Functions</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('sqrt')">square root</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('bitwise')">Bitwise</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('not')">not</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('or')">or</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('xor')">xor</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('and')">and</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('match_regex')">Match Regex</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('capture')">capture</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('xlang')">Cross Language Exec</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('interpolation')">variable interpolation</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('dynaCode')">Dynamic Code</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('load')">load</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('run')">run</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('sockets')">Server &amp; Client</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('server')">server</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('client')">client</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('connect')">connection</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('readDat')">Read Data</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('sendDat')">Send Data</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('closeConn')">Close Connection</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('gc')">Garbage Collection</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('gc-about')">About</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('gc-rate')">Altering the collection rate</a>
		<hr/>
		<a class="side-nav-item-title" onclick="SmoothScroll.scrollToId('additional')">Additional Functions</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('sleep')">sleep</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('time')">time</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('platform')">platform</a>
		<a class="side-nav-item" onclick="SmoothScroll.scrollToId('purge')">purge memory</a>
		<br/><br/>
	</div>


	<div id="content-window">
		
		<div class="section" id="gettingStarted">
			<h2>Getting Started.</h2>
			<p>
				Welcome to latria! I'm glad you're interested in learning about this exciting new scripting language. With latria you can expect to bridge between languages in a jiffy, stand up simple servers in a few lines and more. All in a familiar C style of programming.<br/><br/>
			    This guide will do its best to help you get up and running with latria in as little time as possible. If you follow through from the start you should have enough of an understanding in latria to build your own latria scripts. If you ever have any problems, questions or corrections concerning this guide you can contact me at <a href="mailto:ben@axolsoft.com">ben@axolsoft.com</a>.<br/><br/>
				
			</p>
		</div>
		
		<!--About Latria-->
		<div class="section" id="about">
			<h3>About latria.</h3>
			<p>
				A little about what latria is, what it's intended for, and how it came about. Firstly the project was started on a whim due to issues with embedding lua on certain systems. I am a big fan of lua, but I was wondering what if I wrote something that could be, well, even smaller. Something that was almost less of a langauge and more of a basic management system. A language that you could use to collectively manage your individual scripting languages, and tasks. Think of it like a script for a dispatch system, which just also happens to be it's own standalone system as well.<br/><br/>
				With the intention to create this 'dispatch' language I set about designing a language syntax that would match this. Just a step back to explain another thing as well. I like to say that when we program/script we aren't really making anything. Now that may seem a bit harsh, but truly we're telling the computer to utilize existing resources: memory, pixels on the screen, disk space, etc. to reorganize into our 'program'. The machine you're reading this on was already capable of doing it, it just needed to be told how. With the stress on communication it comes down to one thing, how brief can I be while still expressing proper intent? That is the general issue at hand when programming. Programs that are too concise may not be explaining how to do a task as explicitly as it should, or a bloated program may be explaining far too redundantly how to do some.<br/><br/>
				With latria the intention was to make sure that the language was simple, so intent could always be expressed briefly. If the intent is of a complex nature and requires detailed instructions, it could be written in latria, but the desire was to avoid such complex builds in latria. The incentive to the programmer is to use the embedded bridging feature of latria, a glorified piping mechanism of source. Source code from multiple languages could be written into one file, with instructions embedded on how to interpret the embedded source. The details for this mechanism will be explained in depth later on, but to sum it up developers can write 'frankenstein' scripts in latria, allowing you to dynamically interpolate the outputs of programs into other programs.<br/><br/>
				Well that's about enough said in vaguely technical terms. After first starting the project in December of 2014 the language was opensourced in December of 2015. After about a year's worth of work the language has undergone various reconstructions, tear downs, and changes of focus, but the core concept of language interpolation mentioned above was always kept at the heart. I think it's a fascinating concept to create a language that leverages other languages as one of it's core concepts, after all they may be different, but fundamentally the concepts expressed in all languages can be nearly universally translated. Similar to speaking in spanglish, or another compilation of languages in order to express an idea on the spot in a personally convenient manner, latria is intended to be expressed not by itself but in conjunction with one or more languages to complement itself.
			</p>
		</div>
		
		<!--Getting Latria-->
		<div class="section" id="gettingLatria">
			<h3>Getting Latria.</h3>
			<p>
			You have a few choices when it comes to using latria.<br/><br/>
			For either a prebuilt version or the source visit <a href="http://latria.uphouseworks.com">latria.uphouseworks.com</a>. Links for prebuilt binaries and the source can be found at the bottom of the site.<br/><br/>
			When possible I would recommend that you build latria from source, as the builds may not be as up to date as the current source. Currently there is build support for linux & mac using <span class="code">make mac</span> or <span class="code">make linux</span> from the terminal. For building on windows it's a bit trickier, but I'll elaborate later on.
			</p>
		</div>
		
		<!--Building From Source-->
		<div class="section" id="buildingSource">
			<h3>Building.</h3>
			<p>
			To build latria from source you'll need the code, you can grab that over from the link at <a href="http://latria.uphouseworks.com">latria.uphouseworks.com</a>. Once you have the source you can utilize the <span class="code">make [platform]</span> command from the terminal on mac/linux. Depending on your platform substitute the name for your given platform, for example <span class="code">make mac</span> or <span class="code">make linux</span>. Both of these commands will build a completely standalone version of latria that is capable of compiling and interpreting code. If you wish to create a smaller binary, you can build the interpreter and compiler seperately. For mac, to build the interpreter and compiler you would type the following in the console. <span class="code">make mac-interpreter</span> and <span class="code">make mac-compiler</span> (make sure to run <span class="code">make clean</span> first if you already built the standalone binary).<br/><br/>
			To see more build targets you can run <span class="code">make help</span>, which will list all valid build targets, including the debuggable targets.<br/><br/>
			<!--Building for Windows-->
			To build latria for windows, you'll need to have Visual Studio installed with <a href="https://msdn.microsoft.com/en-us/library/ms229859%28v=vs.110%29.aspx">access to the developer command prompt</a>, which provides the required environment to build under. Nmake is utilized to build on windows, and makes use of an additional nmake compatible Makefile (appropriately called NMakefile).<br/><br/>
			To build latria on windows you invoke nmake on the NMakefile as follows:
			</p>
			
			<p class="code"><br/>
			::Be sure to invoke with /F NMakefile, otherwise nmake will unsuccessfully attempt to use the regular Makefile<br/><br/>
			nmake /F NMakefile latria<br/><br/>
			</p>
			
			<p>
			This creates a standard latria binary, capable of running latria scripts standalone. Some other build options are as follows.
			</p>
			<p class="code"><br/>
			:: makes the interpreter only<br/>
			nmake /F NMakefile interpreter<br/><br/>
			:: makes the compiler only<br/>
			nmake /F NMakefile compiler<br/><br/>
			</p>
		</div>
		
		<!-- Installing -->
		<div class="section" id="installing">
			<h3>Installing.</h3>
			<p>
			To set latria up on your system path for mac/linux you can use <span class="code">make install</span>, which will install the interpreter/compiler on your machine.<br/><br/> For windows there is no supported system installation, simply place it where you want to use it and continue from there.<br/><br/>
			Once you have finished installing latria you can test whether or not latria is installed by running the command <span class="code">latria -v</span> from anywhere on your system (for mac/linux). You should see the version number of latria printed out to the console if it is properly installed.<br/><br/>
			Congratulations, you now have a working copy of latria installed locally! Now we can actually start writing some latria script.
			</p>
		</div>
		
		<!-- First Script -->
		<div class="section" id="firstScript">
			<h3>A Basic Script.</h3>
			<p>
			Keeping in line with the way things work and acknowledging the concept of languages working together, we'll write a simple script to get started.
			</p>
			<p class="code"><br/>
			print("hola mundo!")<br/>
			//a comment, prints 'hola mundo' to the console<br/><br/>
			</p>
			
			<p>
			A 'traditional' hello world program! You can write this up in a file called first.lra and run <span class="code">latria first.lra</span> to execute it. By convention all latria script files end in 'lra', and in an organizational sense it would be best to follow this convention. Now from this script you should see 'hola mundo!' print to the the console screen. If you see this print out then you've successfully run your first script! From here it's a matter of getting the basic syntax down and learning what Latria has to offer in terms of functionality.<br/><br/>
			If you were looking in the directory after running your script you may have noticed the first.lrac file automatically generated, this is the <span style="font-style:italic">compiled</span> latria file that is actually run. I won't delve into details, but latria executes what is referred to as bytecode, something that is generated from the code written in your scripts and stored in the .lrac files. For the most part you need not worry yourself with these files, just know that they are the product of your scripts for latria to execute.
			</p>
		</div>
		
		<!--Basic Syntax-->
		<div class="section" id="syntax">
			<h3>Basic Syntax.</h3>
			<p>
				As a language latria has a fairly non-original syntactical structure. This entire guide goes over each component of the latria language you will encounter and explains how to work with, so here we'll just go over the basics.<br/><br/>
				First off, variables. Variables are textual representations of data. They can be assigned to, passed, and deleted. To 'set' a variable you pass a name, an = and a value to assign.
			</p>
			
			<p class="code"><br/>
				x = 5<br/><br/>
			</p>
			
			<p>
				Now the variable x holds the value 5. You can now use x as it were 5. Here's another example, but with a string. If you're not familiar with the concept you can think of a string as a series of characters 'strung' together. Here we'll assign x to a string, and print it out to the screen.
			</p>
			
			<p class="code"><br/>
				x = "a string of text contained within double quotes"<br/><br/>
				print(x)<br/><br/>
			</p>
			
			<p>
				If done right this should print 'a string of text contained within double quotes'. Note that you can use double or single quotes to contain a string. If you have to include a ' or " inside a string use one or the other to avoid ending the string early. If you have to use both or prefer using one in particular, you can escape ' or " from being seen as a boundary of a string by writing a backslash character \ before.
			</p>
			
			<p class="code"><br/>
				x = 'tom\'s diner'<br/><br/>
				print(x)<br/><br/>
			</p>
			
			<p>
				Code not being spoken or written language we're used to can make it difficult to convey what is intended by that same code. When you wish to add a little info about what it is you're writing in your native tongue, use a comment. A comment can be written 2 ways in latria. Two slashes // or /*  followed by */ (a block comment). When using // everything that follows is a comment until the end of that line. When using /* anything following is a comment until */ is read, even if it means going across multiple lines. Anything in a comment is completely ignored by latria and is strictly for marking up your scripts for you and other users to read. When using comments, use them early, use them often. It's too easy to comment a piece of code and save yourself the dilemma of attempting to reinterpret what it was you originally wrote, in latria or <span style='font-style:italic'>any</span> language for that matter.
			</p>
			
			<p class="code"><br/>
				// this entire line is a comment<br/>
				<br/>
				// x = 2 does nothing since this is a comment<br/>
				<br/>
				/* a block comment on one line */<br/>
				<br/>
				/* <br/>
				a block comment<br/>
				across many<br/>
				lines<br/>
				*/<br/><br/>
			</p>
			
			<p>
				As seen earlier with the 'print' statement, function calls are a major part of latria. Without the print function you would have a difficult time trying to see what latria is doing!<br/><br/>In Latria there are user provided functions and system functions, here I'll be explaining the later (user defined functions are explained later on). Let's look at the print function again. This time let's assign a string to a variable and print the variable instead.
			</p>
			
			<p class="code"><br/>
				// assign a string to x<br/>
				x = "printed out!"<br/><br/>
				// call print with x as the argument<br/>
				print(x)<br/><br/>
				// prints 'printed out!'<br/>
				<br/>
			</p>
			
			<p>
				Function calls are capable of taking expressions instead of raw values or variables as well. See for yourself.
			</p>
			
			<p class="code"><br/>
				// assign 5 to x<br/>
				x = 5<br/><br/>
				// call print with the expression 'x * 4' as the argument<br/>
				print(x * 4)<br/><br/>
				// prints 20<br/>
				<br/>
			</p>
			
			<p>
				As you can see the expression of x * 4, or 5 times 4 is evaluated and passed as it's result to the print function. This kind of functionality can allow you to make many operations on line instead of having to write them out line by line, saving you space and time where complexity is not a concern.
			</p>
			
			<p>
				If you wish to clear a variable, you can 'null' it by setting it equal to a special type called <span class="naranja">null</span>. Setting any variable to null unsets that variable, removing the value and variable simultaneously.
			</p>
			
			<p class="code"><br/>
				// set x to 2<br/>
				x = 2<br/>
				print(x) //2<br/><br/>
				//set x to null<br/>
				x = null<br/>
				print(x) // null (as in not set)<br/><br/>
				// set x to 'baby back ribs!'<br/>
				x = 'baby back ribs!'<br/>
				print(x) // baby back ribs!<br/><br/>
				//set x to null again<br/>
				x = null<br/>
				print(x) // null (as in not set)<br/><br/>
			</p>
			
		</div>
		
		<!--Types-->
		<div class="section" id="types">
			<h3>Types.</h3>
			<p>
			There are 6 data types in latria that you need to be aware of to get started:<br/><br/>
			<span class="naranja">
			Number<br/>String<br/>File<br/>Array<br/>Connection<br/>null</span><br/><br/> 
			<span class="naranja">Strings</span> are a basic type, bounded by either single or double quotes and containing any number of characters up to a closing single or double quote.<br/><br/>
			<span class="naranja">Numbers</span> are represented internally as a 'double' type, providing an acceptable degree of precision. A number value can be set from either a Integer or a Float value, both will be converted to double internally.<br/><br/>
			<span class="naranja">Files</span> are a type that represents an open file handle. These types are set by opening a file and used by standard IO functions.<br/><br/>
			<span class="naranja">Arrays</span> are a type that holds an arbitrary amount of key/value pairs inside of itself. Arrays can hold any type of value (although arrays in arrays are a bit off as of this moment).<br/><br/>
			<span class="naranja">Connections</span> are created when a server received a connection or a client successfully connects to a server. These are used for managing an established connection, such as writing/reading.<br/><br/>
			<span class="naranja">null</span> is a special type used to denote the absence of a value in a variable.
			<br/><br/>
			In latria these types are all associated with variables, which are dynamically typed. This means their type is determined based on the value being assigned to it. Latria automatically handles the variable appropriately based on the underlying type of the value that was assigned to it. The code below shows an example of assigning values of varying types to the same variable.
			</p>
			<p class="code">
				<br/>
				x = 2 //a Number<br/>
				print(x) //prints 2<br/>
				<br/>
				x = "bacon" //a String<br/>
				print(x) //prints 'bacon'<br/>
				<br/>
			</p>
			<p>
			Putting this in a .lra and running it should print out the following:
			</p>
			<p class="output">
				<br/>2<br/>
				bacon<br/><br/>
			</p>
			<p>
			When working with variables it is possible to change the type of a current variable depending on what you assign it to, but latria will always checks the type provided to any binary operator or function to verify it as expected. If it isn't as expected latria will print out an error to let you know.<br/><br/>
			</p>
		</div>
		
		<!-- Basic Math -->
		<div class="section" id="basicMath">
			<h3>Basic Math.</h3>
			<p>
			Arithmetic in latria is straight forward, with PEMDAS order of operations prevailing over compound expressions. An example expression of arithmetic in latria is as follows. Note that the parentheses are respected as aforementioned via PEMDAS.
			</p>
			<p class="code"><br/>
				x = 2 * 3 + (5 * 4 / 2) - 2<br/>
				print(x) //14<br/><br/>
			</p>
			<p>
				The standard arithmetic operators +, -, *, /, ^ and % are supported. Bitwise operators are also supported, but as system functions instead.<br/><br/>All of the aforementioned operators or binary, meaning they work on two elements. Many other languages feature these and <span style='font-style:italic'>unary</span> operators. These work on a single element, such as the ++ increment and -- decrement operators. No unary operators are present in latria.
			</p>
		</div>
		
		<!--Strings-->
		<div class="section" id="strings">
			<h2>Strings.</h2>
			<p>
			Strings in latria are a useful type, allowing you create basic webservers that output data or to read/write from a file. When it comes to strings they are a special case as well, being the only other first class type that can be acted on by the + operator besides Numbers. This is referred to as string concatenation, an example of this is as follows:
			</p>
			<p class="code"><br/>
			x = "latria strings" + " glued together"<br/>
			print(x) //'latria strings glued together'<br/><br/>
			</p>
			<p>
			So, great, we can stick strings together, what else can we do? Beyond this latria provides a suite of built in system functions for performing standard operations with strings. Some of these functions include find, replace, substitution and match.<br/><br/>
			<span id="find"></span>
			<span class="naranja">Find</span> finds a string within a string, and returns the index it was found at. It takes 2 string arguments, the first the target string to search in and the second the string to find within the first string.
			</p>
			<p class="code"><br/>
			x = find("string or string", "or")<br/>
			print(x) //7<br/><br/>
			</p>
			<p>
			<span id="substr"></span>
			This by itself, is not too useful, however if we wish to use this to get a string we can use the <span class="naranja">sub string</span> function with this index we have found.
			</p>
			<p class="code"><br/>
			x = substr("string or string", 7, 9) //takes the substring between the two indexes provided in a string<br/>
			print(x) //'or'<br/><br/>
			</p>
			<p>
			Now what if we wanted to take the sub string from 7 to the end of the string? We can use the same function above with one less argument to achieve this.
			</p>
			</p>
			<p class="code"><br/>
			x = substr("string or string", 7) //takes the substring from 7 to the end of this string<br/>
			print(x) //'or string'<br/><br/>
			</p>
			<p>
			<span id="replace"></span>
			Excellent! We've taken a substring from a string. Now what if we wanted to replace that instead though. We can use the <span class="naranja">replace</span> instead.
			</p>
			<p class="code"><br/>
			x = replace("string or string", "or", "and")<br/>
			print(x) //'string and string'<br/><br/>
			</p>
			<p>
			<span id="match"></span>
			String are pretty maleable with this, but what if we want more? It turns out there's a 4th function to <span class="naranja">match</span> a string within a string by a pattern. This 'pattern' can be as simple as another raw string, like what is provided to find. However this is no ordinary function. This is a regex function! For those of you who know regex, they are a powerful component found almost universally in all languages. The underlying regex engine and the special characters it supports will be detailed later on. A simple example for now is as follows:
			</p>
			<p class="code"><br/>
			x = match("string or string", "or[^s]") //matches 'o' and 'r' followed by anything that is not 's'<br/>
			print(x)//1 (for success, 0 for failure)<br/><br/>
			</p>
			<p>
			Again, I won't go into details right here but capturing and non-capturing parentheses are supported as well, for those who care to know.
			</p>
		</div>
		
		
		<!--Arrays-->
		<div class='section' id='arrays'>
			<h2>Arrays.</h2>
			<p id="initializing">
				Arrays in latria are a special data type that holds a collection of keys and associated values, keys being strings and values being other variables. Utilizing arrays it is possible create complex data structures that can keep track of such things as time sheets, scoreboards, recipe lists and even documentation.
			</p>
			
			<h3>initializing an array.</h3>
			<p>
				First I'll show an example of the syntax for initializing an array, then I'll explain it afterwards.
			</p>
			
			<p class="code"><br/>
				//creates an array with one key/value<br/>
				x = {"animal":"cow"}<br/>
				<br/>
				//creates an array with 2 elements<br/>
				x = {"age":66 , "height":6}<br/><br/>
			</p>
			
			<p id="accessing">
				Creating an array starts with a regular variable assignment, until after the = sign. At this point our array definition begins. An array initializer is always marked with a pair of curly braces {} following an equals sign. Within these curly braces can be 1 or more key/value pairs to initialize the array with. For each key/value pair the key is a string, followed by a colon :, followed by a value or variable to assign to that key. If another key/value pair is desired a comma is used to separate the individual pairs.
			</p>
			
			<h3>accessing an element.</h3>
			<p>
				Accessing an array element allows you to either reference it as a variable or to set it to another value. An example of both getting and setting an array value is below.
			</p>
			
			<p class="code"><br/>
				//setting x to an array with 2 key/value pairs<br/>
				x={"1":"cat" , "2":"dog"}<br/><br/>
				//print the value of "1" in x<br/>
				print(x["1"])<br/><br/>
				//change the value of "1" in x to moose<br/>
				x["1"] = "moose"<br/><br/>
				//print the value of "1" in x again<br/>
				print(x["1"])<br/><br/>
			</p>
			
			<p>
				Accessing an array element is doing with the variable name and a pair of square brackets enclosing the key. When referencing an array element you can either use the value from the key, or reassign a new value to that key. The syntax for the actual reference is the same both ways as shown above.<br/><br/>
				It is also possible to create an array simply by setting an array element on a variable. The variable will be created or converted to an array type behind the scenes and the single key/value will be set. 
			</p>
			
		</div>
		
		
		<!-- Control Flows -->
		<div class="section" id="controlFlows">
			<h2>Control Flows.</h2>
			<p>
				Control flows are an essential part of any language, allowing a developer to create detailed and complex programs and scripts. If you are familiar with C style control flows most of these should be immediately familiar to you. However I will be going over each control flow in detail, so if you feel the need you may quickly pass over this section.
			</p>
			
			<h3 id="if">if.</h3>
			
			<p>
				An if statement is a staple in terms of control flows. With it you can execute code conditionally. When compounded with other if statements you can create a complex program capable of a variety of tasks (such as a language like this!). So first let's look at what a basic if statement looks like.
			</p>
			
			<p class="code"><br/>
				if( 1 == 1 ) {<br/>
					<span class="tab"></span>print("1 is equal to 1")<br/>
				}<br/><br/>
			</p>
			
			<p>
				Now to explain a bit. To start an if statement begins with the 'if' keyword, and is followed by a pair of containing parentheses wrapped around a condition. This condition is a statement that is evaluated to a boolean result. An expression can be created by comparing two values using the following:<br/> equals <span class="code">==</span>, not-equals <span class="code">!=</span>, less-than <span class="code">&lt;</span>, greater-than, <span class="code">&gt;</span>, less-than equals <span class="code">&lt;=</span> and greater-than equals <span class="code">&gt;=</span>.<br/><br/> Expressions can created by compounding these using 'And' <span class="code">&amp;&amp;</span> and 'Or' <span class="code">||</span>. Additionally these expressions can be further compounded using containing parentheses, but we won't be going into detail about that here.<br/><br/>
				  If the expression is evaluated to be true, the code contained within the following curly braces is evaluated. If false the code contained within the curly braces is skipped entirely. This conditional branching is an important concept to note.<br/><br/>
				In our statement the expression <span class="code"> 1 == 1</span> evaluates to true and our print statement is executed.
			</p>
			
			<h3 id="elseif">elseif.</h3>
			
			<p>
				An elseif statement is almost exactly like an if statement. The exception being that an elseif must always follow a preceding if or elseif statement. In this way 2 or more statements can be chained onto each other, creating a list of conditions to try. Although an elseif can follow an if, an if following an if will be treated independently. On any condition evaluating to true, it's contents are executed, and the following statements are skipped. An couple examples are as follows.
			</p>
			
			<p class="code"><br/>
				//an elseif being executed<br/>
				if( 1 == 2 ) {<br/>
					<span class="tab"></span>print("incorrect.")<br/><br/>
				} elseif( 1 == 1 ) {<br/>
					<span class="tab"></span>print("correct!")<br/><br/>
				}<br/><br/>
				//an elseif being executed before another<br/>
				if( 1 == 2 ) {<br/>
					<span class="tab"></span>print("incorrect.")<br/><br/>
				} elseif( 1 == 1 ) {<br/>
					<span class="tab"></span>print("correct!")<br/><br/>
				} elseif( 2 == 2) {<br/>
					<span class="tab"></span>print("also correct, but never run!")<br/><br/>
				}<br/><br/>
			</p>
			
			<h3 id="else">else.</h3>
			
			<p>
				An else statement is another component of an existing 'if' or 'elseif'. It is never on it's own and most always be preceded by an if or elseif statement. You can imagine an else statement something akin to a failsafe condition. If the preceding if or elseif conditions all fail, the else statement will always evaluate to true and be executed. Note that no elseifs can follow an else statement. An example of an else is as follows.
			</p>
			
			<p class="code"><br/>
				if( 1 == 2 ) {<br/>
					<span class="tab"></span>print("this can't be right...")<br/><br/>
				} elseif( 2 == 1 ) {<br/>
					<span class="tab"></span>print("and neither can this")<br/><br/>
				} else {<br/>
					<span class="tab"></span>print("i guess else will have to do!")<br/><br/>
				}<br/><br/>
			</p>
			
			<h3 id="for">for.</h3>
			
			<p>
				The for loop is a construct designed to allow a program to iterate over a section of code a certain number of times. A for loop in latria looks like the following.
			</p>
			
			<p class="code"><br/>
			//an empty for loop<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				Now what exactly did we just see? Well, for starters a for loop is always initiated with the 'for' keyword, after which an opening parenthese, followed by 3 parts and a closing parenthese, follow. It's these three elements that are the key to the functionality of a for loop. The first element, in our case <span class="code"> x = 0 </span> is what's called the initialization. The initialization declares and assigns any variables that must be used for our loop. The second element, <span class="code"> x < 10 </span>, is called the condition. The condition checks the provided condition, and exits the loop when it evaluates to false. The third and final element, <span class="code"> x = x + 1 </span>, is called the afterthought. The afterthought is a line of code that is executed once at the end of every iteration.<br/><br/>
				When you put these three together one can see we are simply assigning x to 0, checking that x is less than 10, and incrementing x by 1 at the end of every iteration. The last bit would be to address those curly braces, which indicate the start and stop of the code we will be looping over. Anything written in here will be executed until the loop evaluates to false. Using the above example we can see this by printing out the value of x every time we loop.
			</p>
			
			<p class="code"><br/>
				//a printing for loop<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/><br/>
				<span class="tab"></span>print(x)<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				This should print out the values 0-9, each on separate lines. So great, we can loop over whatever we like. What if we want to skip an iteration though? This is possible by using the <span class="naranja">continue</span> keyword. Similar to it's usage in C based languages, continue simply skips to the end of the current loop and executes the afterthought (mentioned earlier). Let's say we wanted to skip printing the number 5? We can do that by putting a continue in an if statement.
			</p>
			
			<p class="code">
				//a printing for loop that skips 5<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/><br/>
				<span class="tab"></span>if( x == 5 ) {<br/>
				<span class="tab"></span><span class="tab"></span>//skip this iteration<br/>
				<span class="tab"></span><span class="tab"></span>continue<br/>
				<span class="tab"></span>}<br/>
				<span class="tab"></span>print(x)<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				This prints out the values 0-9 while skipping 5. That's great, but what if we wanted to simple exit the loop altogether at 5? We could alter the condition of the for loop, but we can also use the <span class="naranja">break</span> keyword to 'break' out of the loop. An example of this is as follows
			</p>
			
			<p class="code">
				//a printing for loop that breaks out at 5<br/><br/>
			for( x = 0, x &lt; 10, x = x + 1 ) {<br/><br/>
				<span class="tab"></span>if( x == 5 ) {<br/>
				<span class="tab"></span><span class="tab"></span>//break out<br/>
				<span class="tab"></span><span class="tab"></span>break<br/>
				<span class="tab"></span>}<br/>
				<span class="tab"></span>print(x)<br/>
				<br/>
			}<br/><br/>
			</p>
			
			<p>
				Now this prints out the values 0-4, exiting the loop when the value is 5.
			</p>
			
			<h3 id="while">while.</h3>
			
			<p>
				The while loop is a construct similar to a for loop, allowing a program to loop over a given section of code. A while loop is like a for loop that has no initialization sequence and no afterthought sequence (as mentioned in for), only retaining the condition. This condition is evaluated before each run, and if evaluated to true, executes another loop. When this condition evaluates to false, the loop is exited. An example of a while loop is below.
			</p>
			
			<p class="code"><br/>
				x = 0<br/><br/>
				// a while loop counting up to 10<br/>
				while( x &lt;= 10 ) {<br/>
					<span class="tab"></span>//print x<br/>
					<span class="tab"></span>print(x)<br/>
					<br/>
					<span class="tab"></span>//increment x by 1<br/>
					<span class="tab"></span>x = x + 1<br/>
				}<br/><br/>
			</p>
			
			<p>
				 Similarly to a for loop, you can also use <span class="code">continue</span> and <span class="code">break</span> to skip an iteration or to exit the loop entirely.
			</p>
			
			<p class="code"><br/>
				x = 0<br/><br/>
				// a while loop counting up to 10, but skipping 5<br/>
				while( x &lt;= 10 ) {<br/>
					<span class="tab"></span>if( x == 5 ) {<br/>
					<span class="tab"></span><span class="tab"></span>//increment one up (otherwise we will loop forever) and skip this iteration<br/>
					<span class="tab"></span><span class="tab"></span>x = x +1<br/>
					<span class="tab"></span><span class="tab"></span>continue<br/>
					<span class="tab"></span>}<br/>
					<span class="tab"></span>//print x<br/>
					<span class="tab"></span>print(x)<br/>
					<br/>
					<span class="tab"></span>//increment x by 1<br/>
					<span class="tab"></span>x = x + 1<br/>
				}<br/><br/><br/>
				x = 0<br/><br/>
				// a while loop counting up to 5<br/>
				while( x &lt;= 10 ) {<br/>
					<span class="tab"></span>if( x == 5 ) {<br/>
					<span class="tab"></span><span class="tab"></span>//break out<br/>
					<span class="tab"></span><span class="tab"></span>break<br/>
					<span class="tab"></span>}<br/>
					<span class="tab"></span>//print x<br/>
					<span class="tab"></span>print(x)<br/>
					<br/>
					<span class="tab"></span>//increment x by 1<br/>
					<span class="tab"></span>x = x + 1<br/>
				}<br/><br/>
			</p>
			
		</div>
		
		
		<!-- Functions -->
		<div class="section" id="functions">
			<h2>Functions.</h2>
			<p id="calling">
				Declaring functions allows you to encapsulate functionality that you would otherwise have to continually write out. They are are useful component in simple scripts and can become near essential in complex ones. The functionality of a function in Latria is near identical to those of most other programming languages (minus the initial syntax) and so should be relatively easy to grasp if you're familiar with the concept.
			</p>
			
			<h3>calling.</h3>
			
			<p>
				Some functions have already been provided to you by the system, like <span class="code">print</span>. To call these functions you provide the function name and a parentheses enclosed list of arguments.
			</p>
			
			<p id="declaring" class="code"><br/>
				print("an argument passed to print")<br/><br/>
			</p>
			
			
			<h3>declaring.</h3>
			
			<p>
				Declaring functions is fairly straightforward. For a quick and easy function, you could write one as follows.
			</p>
			
			<p class="code"><br/>
				//a function called 'function'<br/>
				@function() {<br/>
				<br/>
				<span class="tab"></span>print("calling a function!")<br/>
				<br/>}<br/><br/>
				//call 'function'<br/>
				function()<br/><br/>
			</p>
			
			<p>
				So what exactly does everything above do? Well, let's break apart and see what makes a function in latria.<br/><br/>
				To start, a function definition always begins with an '@' symbol. This indicates to latria that what follows is a function definition. After this the name of the function follows. A function name can be any number of alpha numeric characters, but must start with an alpha character. A name like 'a123Function' would work, but a name like '123function' would not. After the function name we have the parameter list contained within parentheses. The parameter list can be empty, or filled with a comma separated list of variables. If you noticed the above example has no parameters, so let's see an example with some.
			</p>
			
			<p class="code"><br/>
				//a function called 'function' that takes variables x,y,z<br/>
				@function(x,y,z) {<br/>
				<br/>
				<span class="tab"></span>print(x+y+z)<br/>
				<br/>}<br/><br/>
				//call function with 1,2,3 passed as arguments<br/>
				function(1,2,3)<br/>
			</p>
				
			<p>
				Notice that since latria uses inferred types there is no control over what kind of variables you can pass to a function. The above function could take numbers <span style="font-style:italic">or</span> strings, or both! This kind of flexibility can come as a double edged blade, allowing you to stretch the applications of a single function definition or to end up performing string math by accident. Name your functions clearly to guard against such mistakes.<br/><br/> Now finally a function body is contained within a pair of curly braces {}. In the examples here you'll see curly braces on the same line as the function definition. This is optional and you can place them anywhere you want so long as the opening brace precedes the function body and the closing brace follows it. Anything that goes between these braces is run as latria code, including other function definitions! It's important to note that when within a function you are within a scope that only has access to the variables passed to it. A scope in this case is referring to a closure that is defined by the function body. Anything within the closure operates with a set of variables independent of any code preceding or following the function when called. A good example of the separation of variables across scopes is below, where the variable x is declared outside of a function and passed as an argument. Although it is altered inside once the function body is exited the value of x returns to what it was before. This is an example of x being declared in scope a, and <span style="font-style:italic">another</span> x being declared in scope b. They may both be called x, but they are distinctly different variables.
			</p>
			
			<p class="code"><br/>
				//set x to 2<br/>
				x=2<br/><br/>
				//create a function that takes x as a parameter<br/>
				@f(x) {<br/>
				<br/><br/>
				<span class="tab"></span>//increment x by 1<br/>
				<span class="tab"></span>x=x+1<br/>
				<br/>
				<span class="tab"></span>//print x<br/>
				<span class="tab"></span>print(x)<br/><br/>
				}<br/><br/>
				//print x, call our function and then print x again to see it has not changed in this scope<br/>
				print(x)<br/>
				f(x)<br/>
				print(x)<br/><br/>
			</p>
			
			<p>
				The above will print x 3 times, showing the original, the 'new' x and the original again. Even though the name of the variable 'x' is the same throughout, the scope changes when the function body is entered. Any variables passed or declared inside a function body remain independent from any variables before. This also means that once you exit the function body any variables you declare will 'fall' out of scope, making them no longer accessible. In most cases this is desirable, as it makes latria memory managed. However when you calculate something that you wish to get back from a function you will most likely want to <span id="returning" class="naranja">return</span> a variable.
			</p>
			
			<h3>returning.</h3>
			
			<p>
				Returning a variable from a function is essential if you wish to have access to the result of your function's work. To do this you simply utilize the <span class='code'>return</span> keyword followed by a space and the variable you wish to return.
			</p>
			
			<p class="code"><br/>
				//declaring a function called 'double' that will double and return our input<br/><br/>
				@double(x) {<br/>
				<br/>
				<span class="tab"></span>x=x*2<br/>
				<br/>
				<span class="tab"></span>//returns x<br/><br/>
				<span class="tab"></span>return x<br/><br/>
				}<br/><br/>
				//call double and assign it to var<br/>
				var = double(5)<br/><br/>
				print(var) //10<br/><br/>
			</p>
			
			<p>
				You can return any variable of any type you wish, but you may only return one. If you wish to return one or more you may declare an array inside your function and return that instead.<br/><br/>An additional note, although variables are limited to scope, function definitions are not <span style="font-style:italic">currently</span> held by this same limitation. Functions declared within functions are available globally regardless of how nested they may be. I want to make sure that you as the developer are aware of this in the meantime while it is an outstanding issue.
			</p>
			
		</div>
		
		
		<!-- Random -->
		<div class="section" id="random">
			<h2>Random.</h2>
			<p id="rand">
			Latria encapsulates the standard 'rand' function in C. Making it available via the function <span class="naranja">random</span>. It's takes one Number argument and returns a Number.
			</p>
			<p class="code"><br/>
			x = random(1024)<br/>
			print(x) //a random number between 0 and 1023<br/><br/>
			</p>
			<p id="seed">
			The rand function is a pseudorandom number generator. Meaning it's output is predictable from a given seed. In order to prevent random from returning the same series of values on startup it is recommended that you alter it using the <span class="naranja">seed</span> function, which takes one Number arg and does not return a value.
			</p>
			<p class="code"><br/>
			//x is equal to a previously obtained arbitrary Number<br/>
			seed(x) //seeds the random number generator with this Number<br/><br/>
			y = random(1024)<br/>
			print(y) //a 'hopefully' unexpected random number between 0 and 1023<br/><br/>
			</p>
			<p>
			With these two functions you can create a reliable prng (pseudo-random number generator) to create psuedo-arbitrary values from.
			</p>
		</div>
		
		<div class="section" id="input">
			<h2>Input.</h2>
			<p>
			Reading user input is a simple but important feature of any language. In latria it is achieved via the <span class="naranja">input</span> function. When called it halts until the user finishes typing their input and hits enter. Upon completion it returns a String value.
			</p>
			<p class="code"><br/>
			x = input() //waits for user to enter input<br/>
			print("You entered: " + x)<br/><br/>
			</p>
			<p>
			User input can be used to allow selections, seeding of random values and even to chat in a simple server/client setup.
			</p>
		</div>
		
		<!-- File IO -->
		<div class="section" id="fileio">
			<h2>File IO.</h2>
			<p>
			In latria the ability to read files is an important aspect. Reading and writing files is supported, but binary is not (potentially in the future when a 'char' type is added). In keeping with the overall design, reading from files is incredibly simply, reading only 1 line at a time. Writing is straightforward as well, writing only one line at a time. All the file modes that are supported in C ( w, r, r+, a+, etc.) are supported in latria.<br/><br/>
			</p>
			
			<h3 id="open">Opening a file.</h3>
			<p>
				To open a file you can use the <span class="naranja">open</span> function, which takes two string arguments. The first is the name of the file, and the second is the mode to open it in ( r, w, a+, etc.). On success this function will return a valid pointer to a file that can used in latria.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "r")<br/><br/>
			</p><br/>
			
			<h3 id="read">Reading from a file.</h3>
			<p>
			To read from a file you use the <span class="naranja">read</span> function, which takes a single File argument. It will return lines or null on the reaching the end of the file.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "r")<br/>
			line = read(x)<br/>
			print(line) //a line we read from 'file.txt'<br/><br/>
			</p>
			
			<h3 id="write">Writing to a file.</h3>
			<p>
			To write to a file you use the <span class="naranja">write</span> function, which takes a File argument and a String argument. The string value is written out as a line in the file.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "w")<br/>
			write(x,"a line!") //writes a line into this file<br/><br/>
			</p>
			
			<h3 id="close">Closing a file.</h3>
			<p>
			Once you are done reading or writing to a file use <span class="naranja">close</span> to close the file. It takes a single argument, being the File to close.
			</p>
			<p class="code"><br/>
			x = open("file.txt", "r")<br/>
			line = read(x)<br/>
			print(line)<br/><br/>
			close(x) //closes this file<br/><br/>
			</p>
			
			<h3 id="remove">Removing a File.</h3>
			<p>
			If you wish to remove a file completely you can call <span class="naranja">remove</span> to delete it. Remove takes the name of the file as a String argument.
			</p>
			<p class="code"><br/>
			remove("file.txt") //deletes this file<br/><br/>
			</p>
		</div>
		
		<!-- Math -->
		<div class="section" id="math">
			<h2 id="sqrt">Math.</h2>
			<p>
				Latria provides only one math function at this time, the <span class="naranja">square root</span> function. It takes one Number argument and returns the square root of the given value.
			</p>
			<p class="code"><br/>
			x = sqrt(64)<br/>
			print(x) //8<br/><br/>
			</p>
		</div>
		
		<!-- Bitwise -->
		<div class="section" id="bitwise">
			<h2>Bitwise.</h2>
			<p>
				Latria provides bitwise operations in the form of function calls. The provided bitwise functions are listed below with examples:
			</p>
			
			<h3 id="not">not.</h3>
			<p>
				The bitwise 'not' operator is expressed using the function <span class="naranja">not</span>. It is often referred to as the complement operator, performing a logical negation on the bits of the passed in value. 0's become 1's, and 1's become 0's, 'flipping' the value.
			</p>
			<p class="code"><br/>
				x = not(100)<br/>
				print(x) //-101<br/><br/>
			</p>
			
			<h3 id="or">or.</h3>
			<p>
				The bitwise inclusive or (or) operator is expressed using the function <span class="naranja">or</span>. It takes two Number arguments. The resulting output bits are 0 for each position where bits in both arguments are 0, otherwise they are 1.
			</p>
			<p class="code"><br/>
				x = or(101,500)<br/>
				print(x) //501<br/><br/>
			</p>
			
			<h3 id="xor">xor.</h3>
			<p>
				The bitwise exclusive or (xor) operator is expressed using the function <span class="naranja">xor</span>. It takes two Number arguments. The resulting output bits are 1 for each position where only the first bit is 1 or only the second bit is 1, otherwise they are 0.
			</p>
			<p class="code"><br/>
				x = xor(101,500)<br/>
				print(x) //401<br/><br/>
			</p>
			
			<h3 id="and">and.</h3>
			<p>
				The bitwise and (and) operator is expressed using the function <span class="naranja">and</span>. It takes two Number arguments. The output bits are the result of the first and second bit being multiplied.
			</p>
			<p class="code"><br/>
				x = and(101,500)<br/>
				print(x) //100<br/><br/>
			</p>
			
		</div>	
		
		<!-- Match Regex -->
		<div class="section" id="match_regex">
			<h2>Match Regex.</h2>
			<p>
				A basic regular expressions engine is provided in latria for matching purposes. It supports most of the basic regular expression syntax with a few exceptions (most notably look-ahead and look-behind). This engine can be used to match against strings and to even return the portion matched within a string.
			</p>
			<p>
				Regular expressions are utilized by calling the <span class="naranja">match</span> function. Which takes two parameters, a target string, and a string representation of a regular expression to use on the target string.
				A simple example is as follows.
			</p>
			<p class="code"><br/>
				x = match("a basic string", "basic") //will return 1 for a match and 0 for a non-match<br/>
				print(x) //prints 1, indicating a match (0 is a non-match)<br/><br/>
			</p>
			<p>
				A simple match, so let's try something a little more substantial.<br/>Let's try and match anything starting with 'b'.
			</p>
			<p class="code"><br/>
				x = match("a less basic string", "b.*") //matching b followed by anything<br/>
				print(x) //1<br/><br/>
			</p>
			<p>
				So far so good, but we can do better with capturing parentheses.<br/>
			</p>
			<h3 id="capture">capture.</h3>
			<p>
				Capturing parentheses are supported in latria, allowing you to match and return specific sub-strings.<br/>
			</p>
			<p class="code"><br/>
				x = match("a simple string", "(simple)") //searches for 'string' and returns 1 if found in the target string<br/>
				x = capture(0) //returns the first completed capture 'simple'<br/><br/>
				// a more complex match<br/><br/>
				x = match("another string", "([a-z]+)\s")<br/>
				x = capture(0) //returns the first completed capture, 'another'<br/><br/>
			</p>
		</div>
		
		
		<!-- XLang -->
		<div class="section" id="xlang">
			<h2>Cross Language Execution.</h2>
			<p>
				It's an important point to stress that latria's strength is in how it works with other languages. Executing code in a shell environment can open up a wealth of potential resources to be used as you see fit.
				It is these additional resources that can be utilized to 'extend' latria's functionality on a system by system basis. This comes as a doubly beneficial aspect, providing a way to retrofit latria on the go and allowing you to utilize other scripts and programs that you have on your local machine.
				<br/><br/>
				With all of that said, this part of latria is just a glorified 'piping' or 'bridging' mechanism. Even so it stands out in a unique syntactical style all it's own, as well as allowing multiple lines in your script to be executed in the same shell. This multi-line aspect becomes incredibly useful for literally inlining other languages (when needed), or simply to include a few configuration steps in addition to calling another program or script. Anything that would be valid in a shell environment on your local machine would be just as valid here.<br/><br/>
				So, how does this work? Latria provides a special syntax to execute code in a shell on your local system. 
				It is defined by an opening and closing block sequence, both of which must not be followed or preceded by anything (with the exception of assigning the block's result to a variable, that will come up in a moment)<br/><br/>
				Here's a simple example below.
			</p>
			
			<p class="code"><br/>
				//opening sequence, after this everything is executed verbatim in a shell environment (including comments) up to a valid closing sequence<br/>
				##<br/>
				echo done on the shell<br/>
				#><br/>
				//closing sequence, after this everything is interpreted normally as latria code<br/><br/>
			</p>
			
			
			<p>
				Now upon running this you may have realized something, nothing happens. Well, technically <span style="font-style:italic">something</span> happens. 
				The issue is that we're just not capturing what our <span style="font-style:italic">shell</span> did. It certainly did echo the provided statement, but only to itself and not out to latria.<br/><br/>
				We can rectify this by assigning the result of our shell to a latria variable. Modifying the example above, assignment looks a little something like this.
			</p>
			
			<p class="code"><br/>
				//assigns the result of what is executed on the shell below into the variable 'var'<br/><br/>
				var##<br/>
				echo done on the shell<br/>
				#><br/><br/>
				print(var) //prints 'done on the shell\n' (note the extra linebreak that comes from the shell output)<br/><br/>
			</p>
			
			<p>
				With this you can execute whatever you'd like in latria and be able to include results from system shell executions. Additionally these shell executions can be spread out across as many lines as you like for legibility.<br/><br/>
				There is an important rule you must regard however. An opening sequence must <span style="font-style:italic">never</span> be followed by code, and a closing sequence must <span style="font-style:italic">never</span> be preceded by code.<br/><br/>
				A few examples of this are as follows.
			</p>
			
			<p class="code"><br/>
				//can't do this<br/>
				var##echo this<br/>
				#><br/><br/>
				
				//or this<br/>
				var##<br/>
				echo this#><br/><br/>
				
				//or this<br/>
				var##echo this#><br/><br/>
			</p>
			
			<h3 id="interpolation">interpolation.</h3>
			
			<p>
				We can get output from our shell executions, but what if we want to alter what we send programmatically?
				To solve this variable interpolation is supported in shell executions. The syntax is a bit bulky, but it's designed to be very obvious regardless of what language you're interpolating a latria variable into, minimizing any confusion on where and when you're interpolating a value.
			</p>
			<p class="code"><br/>
				<br/>
				//assign x to 'bacon'<br/>
				x = 'bacon'<br/>
				<br/>
				//interpolate x into our shell execution<br/>
				var##<br/>
				echo IN{x}<br/>
				#><br/>
				<br/>
				print(var) //prints 'bacon\n'<br/><br/>
			</p>
			
			<p>
				It is important to note that currently only variables are supported in this form of interpolation. In the future function calls will be as well.
			</p>
		</div>
		
		<!-- Dynamic Code -->
		<div class="section" id="dynaCode">
			<h2>Dynamic Code.</h2>
			<p>
				Since Latria is a scripting language it can be interpreted dynamically, which gives us the opportunity to execute latria code from inside latria or to execute additional latria scripts. This gives incredible flexibility to latria, allowing one to modularize their code and simply load up that section when needed. This means changes are reflected quickly, and there is no need to recompile latria code repeatedly, this is handled for you on an as needed basis.
			</p>
			
			<h3 id="load">load.</h3>
			<p>
				Load allows you to run a latria script in the context of your current script. The child script you fire up will have access to all of the current variables and functions that are available to your calling script's scope.<br/><br/>This function is provided as <span class="naranja">load</span> and only takes 1 argument, the relative path to the script to load.
			</p>
			
			<p class="code"><br/>
				//loads a latria script<br/>
				load("myscript.lra")<br/><br/>
			</p>
			
			<h3 id="run">run.</h3>
			
			<p>
				Run allows you to attempt to dynamically interpret and run latria code from a string. This is provided as the function <span class="naranja">run</span> and only takes 1 argument, the string to interpret and run as latria code.
			</p>
			
			<p class="code"><br/>
				//assign a string<br/>
				x = "print('valid latria')"<br/><br/>
				//attempt to interpret and run this string as latria code<br/>
				run(x) //prints 'valid latria'<br/><br/>
			</p>
		</div>
		
		
		<div class="section" id="sockets">
			<h2>Server &amp; Client.</h2>
			<p>
				In today's world nearly everything is interconnected. In response latria incorporates server and client functionality as a basic need in this day and age. With the built in support for server and client functionality setting up either can be done in as few as a couple lines of code. When a connection is established both parties can either read, write or terminate the connection.<br/><br/>
			</p>
			
			<h3 id="server">server.</h3>
			<p>
				Setting up a server in latria is a very straightforward process. To set up a server one need only call the <span class="naranja">startServer</span> function. This function takes only one number argument, the port number to bind to. An example of starting a server is as follows.
			</p>
			
			<p class="code"><br/>
				/*<br/>
				listens for an incoming connection on port 5000<br/>
				NOTE this blocks until the script is terminated or an incoming connection is made<br/>
				*/<br/><br/>
				
				x = startServer(5000)<br/>
				<br/>
				//'x' now references an established connection (successful or failed)<br/><br/>
			</p>
			
			<p>
				Be aware that calling this function will block until a connection is made.
			</p>
			
			<h3 id="client">client.</h3>
			
			<p>
				A client side application in latria is just about as simple as it is to create a server-side one. The <span class="naranja">connect</span> function is called with two arguments, a string of the ip address (IPv4) to connect to and a number for the port to try. Similarly to the 'startServer' function, the 'connect' function returns what's referred to as a 'connection' object. That will be explained in just a moment, but first let's see how connecting to a server looks written out.
			</p>
			
			<p class="code"><br/>
				//attempts to connect to a server at the address on the port given<br/><br/>
				x = connect("127.0.0.1", 5000)<br/>
				//'x' now references an established connection (successful or failed)<br/><br/>
			</p>
			
			
			<h3 id="connection">connection.</h3>
			
			<p>
				As mentioned before a connection is managed via a 'connection' object. A connection object is returned from 'startServer' or 'connect' when a connection is established. When a connection attempted by the 'connect' function fails however, it returns a -1 value, which should be checked before continuing.<br/><br/>
				A connection is a first class citizen, capable of being passed and returned like any other value. Once a connection has been obtained it can be manipulated by 3 distinct functions: readData, sendData and closeConnection.
			</p>
			
			<h3 id="readDat">Read Data.</h3>
			
			<p>
				Reading data from an established connection is done through the <span class="naranja">readData</span> function, which takes 1 established connection as an argument and returns a string of the data read. It is important to note that this is a blocking call, and will remain so until data is available to be read from the connection. With this in mind take care not to immediately call 'readData' when it is possible there may not be data to read. If you do this there is a risk of a hangup with both sides simply listening forever! With that noted, here's an example of reading data from an established connection.
			</p>
			
			<p class="code"><br/>
				//connect to a server on port 5000<br/>
				x = connect("127.0.0.1", 5000)<br/>
				<br/>
				//read data from our connection, returns a string<br/>
				read = readData(x)<br/>
				<br/>
				//print what we read<br/>
				print(read)<br/><br/>
			</p>
			
			<h3 id="sendDat">Send Data.</h3>
			
			<p>
				Sending data through an established connection is done through the <span class="naranja">sendData</span> function, which takes an established connection and a string value to send as arguments. It returns a number value of the number of bytes written to the output stream. If you send a string such as "meep meep" and 'sendData' returns a value of 0 you can be relatively sure that the other side has disconnected or is otherwise no longer available. Here's an example of sending over an established connection and checking if we sent successfully using an if-else statement.
			</p>
			
			<p class="code"><br/>
				//connect to a server on port 5000<br/>
				x = connect("127.0.0.1", 5000)<br/>
				<br/>
				result = sendData(x,"meep meep")<br/>
				<br/>
				//check the value to make sure we wrote out successfully<br/>
				if(result == 0) {<br/>
					<span class="tab"></span>print("Error! Was unable to write to the stream.")<br/>
				} else {<br/>
					<span class="tab"></span>print("Success!")<br/>
				}<br/><br/>
			</p>
			
			<h3 id="closeConn">Close Connection.</h3>
			
			<p>
				Closing an established connection is something you should make a habit of when you're all done. It's a manner of good housekeeping, to speak. Closing a connection frees up not only the associated variable but also any underlying resources the system has involved in this connection as well. To do this you call the <span class="naranja">closeConnection</span> function, passing a connection argument. Below is an example of the whole connection life cycle from the client's perspective with the connection being closed at the end.
			</p>
			
			<p class="code"><br/>
				//Shows the whole cycle of connecting to a server, sending data, reading data, and closing the connection<br/><br/>
				//connect to a server on port 5000<br/>
				x = connect("127.0.0.1", 5000)<br/>
				<br/>
				result = sendData(x,"meep meep")<br/>
				<br/>
				//check the value to make sure we wrote out successfully<br/>
				if(result == 0) {<br/>
					<span class="tab"></span>print("Error! Was unable to write to the stream.")<br/>
				} else {<br/>
					<span class="tab"></span>print("Wrote successfully!")<br/>
				}<br/><br/>
				//reads data from the connection source<br/>
				read = readData(x)<br/>
				<br/>
				//prints what we read<br/>
				print(read)<br/><br/>
				//Closes our connection<br/>
				closeConnection(x)<br/><br/>
			</p>
		</div>
		
		<!-- Garbage Collection -->
		<div class="section" id="gc">
			<h2>Garbage Collection.</h2>
			
			<p>
				Latria is a garbage collected language. The user need not worry about managing memory manually. On the other hand it is important that this 'garbage collection' is given attention, as it can lead to undesirable circumstances should the user not be careful. The summary below is a bit technical but I recommend you going over it.
			</p>
			
			<h3 id="gc-about">About.</h3>
			
			<p>
				To start I'll relate the inner workings in an abstract way. Normally a GC could be described by such things as conservative, precise, mark-and-sweep, incremental, etc. The GC in Latria does not fit into any one of these categories completely, and in a technical sense it isn't even really a GC at all. The way this collection system works is something that can be generally described as follows.<br/><br/>
				Imagine a recycling plant that takes whatever you give them. When possible they recycle and return whatever is given to them. It's easy to imagine that over time they would inevitably end up with a large quantity of unusable junk which they would have to eventually dispose of. They would like to dispose of this junk as infrequently as possible, as it takes a large amount of time to do, so they wait until they can't handle anything else. Once they're reached capacity, they dispose of everything they're holding, creating room for more junk/recyclables.<br/><br/>
				Ultimately Latria's 'garbage collector' is more accurately a dynamically formed memory pool. This pool is very similar to the aforementioned recycling plant. Every time you set a variable to <span class="code">null</span> or a variable falls out of scope, it is trashed. These trashed variables end up in our pool. In addition to the variables you see, <span style="font-style:italic">all</span> latria's allocation logic is managed by way of this pool. When any allocations are made (internally or by the user) latria makes a request to the pool for a block. The pool then rummages around through it's 'junk' and looks for a chunk of memory that is of the appropriate size. Upon finding a block that is at least large enough, the pool returns that block (a pointer to it to be exact). If the pool does not find a valid block it defers to requesting a block via a managed call to malloc.<br/><br/>
				Great, so now we have a chunk of memory to do with as we please. What happens when we no longer want this memory? We return it to the system! Now in C this is usually achieved via the 'free' function, which does as it says. However, in C, there is not only an overhead to allocation, but also to freeing. In addition, memory is memory. It's universal despite what it may be containing. With this in mind, Latria attempts to recycle memory rather than free it. Not only can we avoid a future malloc but we can potentially keep our memory footprint indefinitely small<br/><br/> 
				With this scheme a few issues rise though. One being we can only hold so much memory to recycle before we need to start giving back, and two we don't have a way of telling whether two variables reference the same underlying object. Within latria itself, this is not a problem. The calls to allocate and free memory are synonymous with malloc and free in how they are utilized. The problem of multiple references to a single object becomes an issue when the user assigns a File value to an additional variable. When done both variables will reference the same File, and if one is closed the other will become an invalid pointer. It is at this point that this designs becomes, faulty. When working with such objects it is best to avoid multiple references when possible, and when not possible they should be treated with caution.<br/><br/>
				To more technically describe this memory is freed to and allocated from the pool's contents whenever possible. When not possible the pool is bypassed and memory is asked for using a managed call to malloc. When this memory is freed later on it is added to the pool as an additional resource. When latria is shutdown or a scope is exited any allocated memory from the enclosing scope or the latria vm is sent to this pool. When the pool exceeds a certain size latria momentarily defers itself to managing the flushing of the pool. Generally this goes unnoticed, but should the user allow an enormous max program size (more on that later), a flush could very well freeze the program for a few seconds or more. However the default maximum pool size should be more than sufficient to allow for smooth operation.<br/><br/>
				
			</p>
			
			<h3 id="gc-rate">Altering the collection rate.</h3>
			
			<p>
				So, having established that this GC is more along the lines of a recycler, how do we indicate how much we're willing to hold? Their is a function <span class="code">__setGCRate</span> which takes a single number value, the value by which to multiply the pool's size. The baseline pool size is 1024 bytes. Passing 2.0 would double the pool size, while 0.5 would halve it. By running your program with a pool size of 0 you can run latria at just over 500kb. Using the aforementioned function you could modify the 'collection' rate as follows.
			</p>
			
			<p class="code"><br/>
				//sets the pool size to 0, freeing all memory immediately after being added to the pool<br/>
				__setGCRate(0.0)<br/><br/>
				//note this has a performance hit, but if memory is an issue latria can run at just over 500kb using this<br/><br/>
			</p>
			
		</div>
		
		<!-- Additional Functions -->
		<div class="section" id="additional">
			<h2>Additional Functions.</h2>
			
			<p>
				The following are additional latria functions that didn't quite make it into a category of their own. While they are important, they can be summed up here.
			</p>
			
			<h3 id="sleep">sleep.</h3>
			
			<p>
				The <span class='naranja'>sleep</span> function is called with a single number argument, indicating the number of seconds to sleep.
			</p>
			
			<p class="code"><br/>
				//sleeps for 2 seconds<br/>
				sleep(2)<br/><br/>
			</p>
			
			<h3 id="time">time.</h3>
			
			<p>
				Returns the current time as a number since 00:00 hours, Jan 1, 1970 UTC. You can get this time by calling <span class="naranja">time</span> with no arguments.
			</p>
			
			<p class="code"><br/>
				//gets the current time since 00:00 hours, Jan 1, 1970 UTC<br/>
				x = time()<br/>
				<br/>
			</p>
			
			<h3 id="platform">platform.</h3>
			
			<p>
				Returns the name of the platform as a string that this instance of latria was compiled for. Called via the function <span class="naranja">platformName</span> with no arguments. The possible values it can return are mac, linux, windows, or undefined.
			</p>
			
			<p class="code"><br/>
				//returns the platform name<br/>
				x = platformName()<br/><br/>
				//prints the platform name<br/>
				print(x)<br/><br/>
			</p>
			
			<h3 id="purge">purge memory.</h3>
			
			<p>
				Purges all allocated variables, functions, etc. You can call this via the function <span class="naranja">__purge</span> with no arguments and no return value.
			</p>
			
			<p class="code"><br/>
				//set x to something<br/>
				x = "something"<br/>
				//prints 'something'<br/>
				print(x)<br/>
				<br/>
				__purge()<br/>
				<br/>
				//prints 'null'<br/>
				print(x)<br/><br/>
			</p>
			
		</div>
		
		<!--TEMPLATE-->
		<!--
		<div class="section" id="bitwise">
			<h2>Bitwise.</h2>
			<p>
				Latria provides bitwise operations in the form of function calls. The provided bitwise functions are listed below with examples:
			</p>
			
			<h3 id="not">not.</h3>
			<p>
				The bitwise 'not' operator is expressed using the function <span class="naranja">not</span>. It is often referred to as the complement operator, performing a logical negation on the bits of the passed in value. 0's become 1's, and 1's become 0's, 'flipping' the value.
			</p>
			<p class="code"><br/>
				x = not(100)<br/>
				print(x) //-101<br/><br/>
			</p>
		</div>
		-->
			
	</div>

</div>
		
		
<!--Footer-->
<div id="footer">

	<div class='footer-section'>
		<p class='footer-section-title'>Contact</p>
		<a class='footer-section-item' href="mailto:friedman.benjamin@gmail.com"><span class="fa fa-envelope fa-2x"></span></a><br/>
		<a class='footer-section-item' href="https://github.com/montymxb"><span class="fa fa-github fa-2x"></span></a>
	</div>

	<div class='footer-section'>
		<p class='footer-section-title'>Home</p>
		<a class='footer-section-item' href="http://uphouseworks.com">uphouseworks.com</a>
	</div>
	
	<div class='footer-section'>
		<p class='footer-section-title'>Work</p>
		<a class='footer-section-item' href="http://www.axolsoft.com">axolsoft</a>
	</div>

	<div class='footer-section'>
		<p style='font-size: 16px; color: #707070'>Guide Revision 3 for Latria v0.1.0</p>
		<p style='font-size: 16px; color: #707070'>Copyright  2015 Benjamin Wilson Friedman, All rights reserved.</p>
	</div>
</div>

</body>
</html>